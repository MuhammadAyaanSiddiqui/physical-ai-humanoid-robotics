"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[492],{698:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>t,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-4-vla/ch13-humanoid-control/manipulation","title":"Humanoid Manipulation and Grasping","description":"Learning Objectives","source":"@site/docs/module-4-vla/ch13-humanoid-control/manipulation.md","sourceDirName":"module-4-vla/ch13-humanoid-control","slug":"/module-4-vla/ch13-humanoid-control/manipulation","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/manipulation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-vla/ch13-humanoid-control/manipulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Balance Control and Stabilization","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/balance-control"},"next":{"title":"Vision-Language-Action (VLA) Pipeline","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch14-multimodal/vla-pipeline"}}');var o=r(4848),l=r(8453);const t={},i="Humanoid Manipulation and Grasping",s={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Part 1: Grasp Planning",id:"part-1-grasp-planning",level:2},{value:"Part 2: Force Control",id:"part-2-force-control",level:2},{value:"Part 3: Pick and Place Pipeline",id:"part-3-pick-and-place-pipeline",level:2},{value:"Summary",id:"summary",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"humanoid-manipulation-and-grasping",children:"Humanoid Manipulation and Grasping"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Implement grasp planning for various object shapes"}),"\n",(0,o.jsx)(n.li,{children:"Use force/torque feedback for stable grasping"}),"\n",(0,o.jsx)(n.li,{children:"Perform pick-and-place operations"}),"\n",(0,o.jsx)(n.li,{children:"Handle manipulation failures gracefully"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Estimated Time"}),": 3-4 hours"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"part-1-grasp-planning",children:"Part 1: Grasp Planning"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass GraspPlanner:\n    def __init__(self):\n        self.gripper_width = 0.08  # meters\n        self.grasp_force = 10.0     # Newtons\n\n    def plan_parallel_grasp(self, object_width, object_center):\n        """\n        Plan parallel jaw grasp for object\n\n        Returns: (approach_pose, grasp_pose, close_distance)\n        """\n        # Approach from above\n        approach_pose = object_center.copy()\n        approach_pose[2] += 0.15  # 15cm above object\n\n        # Grasp at object center\n        grasp_pose = object_center.copy()\n\n        # Close distance based on object width\n        close_distance = object_width - 0.01  # Leave 1cm gap\n\n        if close_distance > self.gripper_width:\n            print(f"\u26a0\ufe0f Object too wide ({object_width:.3f}m > {self.gripper_width:.3f}m)")\n            return None\n\n        return {\n            \'approach\': approach_pose,\n            \'grasp\': grasp_pose,\n            \'close_distance\': close_distance\n        }\n\n# Example\nplanner = GraspPlanner()\n\nobject_center = np.array([0.5, 0.2, 0.75])\nobject_width = 0.05  # 5cm cube\n\ngrasp_plan = planner.plan_parallel_grasp(object_width, object_center)\n\nif grasp_plan:\n    print(f"Approach: {grasp_plan[\'approach\']}")\n    print(f"Grasp: {grasp_plan[\'grasp\']}")\n    print(f"Close gripper to: {grasp_plan[\'close_distance\']:.3f}m")\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"part-2-force-control",children:"Part 2: Force Control"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class ForceController:\n    def __init__(self, desired_force=10.0, kp=0.1):\n        self.desired_force = desired_force\n        self.kp = kp\n\n    def adjust_gripper(self, measured_force):\n        """\n        Adjust gripper based on force feedback\n\n        Returns: velocity command for gripper\n        """\n        error = self.desired_force - measured_force\n        velocity = self.kp * error\n\n        # Safety limits\n        if measured_force > 20.0:\n            print("\u26a0\ufe0f Excessive force! Opening gripper")\n            return -0.05  # Open slowly\n\n        return velocity\n\n# Example\nforce_ctrl = ForceController(desired_force=10.0)\n\n# Gripper not squeezing hard enough\nmeasured = 5.0\ncmd = force_ctrl.adjust_gripper(measured)\nprint(f"Force error: {10.0 - measured:.1f}N \u2192 Gripper velocity: {cmd:.3f}")\n\n# Gripper squeezing too hard\nmeasured = 15.0\ncmd = force_ctrl.adjust_gripper(measured)\nprint(f"Force error: {10.0 - measured:.1f}N \u2192 Gripper velocity: {cmd:.3f}")\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"part-3-pick-and-place-pipeline",children:"Part 3: Pick and Place Pipeline"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class PickAndPlaceController:\n    def __init__(self):\n        self.grasp_planner = GraspPlanner()\n        self.force_controller = ForceController()\n        self.state = "IDLE"\n\n    async def execute_pick_and_place(self, object_info, place_location):\n        """\n        Complete pick and place operation\n\n        States: IDLE \u2192 APPROACH \u2192 GRASP \u2192 LIFT \u2192 CARRY \u2192 PLACE \u2192 RELEASE \u2192 IDLE\n        """\n        # 1. Plan grasp\n        self.state = "PLANNING"\n        grasp_plan = self.grasp_planner.plan_parallel_grasp(\n            object_info[\'width\'],\n            object_info[\'position\']\n        )\n\n        if not grasp_plan:\n            return False\n\n        # 2. Approach object\n        self.state = "APPROACH"\n        await self.move_to(grasp_plan[\'approach\'])\n\n        # 3. Descend to grasp\n        self.state = "GRASP"\n        await self.move_to(grasp_plan[\'grasp\'])\n\n        # 4. Close gripper\n        await self.close_gripper(grasp_plan[\'close_distance\'])\n\n        # 5. Lift object\n        self.state = "LIFT"\n        lift_pose = grasp_plan[\'grasp\'].copy()\n        lift_pose[2] += 0.10  # Lift 10cm\n        await self.move_to(lift_pose)\n\n        # 6. Carry to place location\n        self.state = "CARRY"\n        carry_pose = place_location.copy()\n        carry_pose[2] += 0.10  # Stay 10cm above\n        await self.move_to(carry_pose)\n\n        # 7. Descend to place\n        self.state = "PLACE"\n        await self.move_to(place_location)\n\n        # 8. Release object\n        self.state = "RELEASE"\n        await self.open_gripper()\n\n        # 9. Retract\n        self.state = "RETRACT"\n        retract_pose = place_location.copy()\n        retract_pose[2] += 0.10\n        await self.move_to(retract_pose)\n\n        self.state = "IDLE"\n        return True\n\n    async def move_to(self, target_pose):\n        """Placeholder for motion execution"""\n        print(f"Moving to {target_pose}")\n        # In real system: call MoveIt, wait for completion\n\n    async def close_gripper(self, distance):\n        """Placeholder for gripper control"""\n        print(f"Closing gripper to {distance:.3f}m")\n\n    async def open_gripper(self):\n        """Placeholder for gripper control"""\n        print("Opening gripper")\n\n# Usage\ncontroller = PickAndPlaceController()\n\nobject_info = {\n    \'width\': 0.05,\n    \'position\': np.array([0.5, 0.2, 0.75])\n}\n\nplace_location = np.array([0.3, -0.1, 0.80])\n\n# await controller.execute_pick_and_place(object_info, place_location)\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"\u2705 Grasp planning for parallel jaw grippers"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 Force control for stable grasping"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 Complete pick-and-place state machine"}),"\n",(0,o.jsx)(n.li,{children:"\u2705 Error handling and recovery"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Module 4 Chapter 13 Complete!"})}),"\n",(0,o.jsxs)(n.p,{children:["Continue to ",(0,o.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-4-vla/ch14-multimodal/vla-pipeline",children:"Chapter 14: Multi-Modal Integration \u2192"})]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>i});var a=r(6540);const o={},l=a.createContext(o);function t(e){const n=a.useContext(l);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);