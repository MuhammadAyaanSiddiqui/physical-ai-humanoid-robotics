"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[2346],{2841:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-simulation/ch5-gazebo/physics-parameters","title":"Tuning Physics Parameters in Gazebo","description":"A simulation is only as good as its physics. To create realistic and stable simulations, you must understand how to tune Gazebo\'s physics parameters. These settings control everything from how objects fall to how they interact upon collision.","source":"@site/docs/module-2-simulation/ch5-gazebo/physics-parameters.md","sourceDirName":"module-2-simulation/ch5-gazebo","slug":"/module-2-simulation/ch5-gazebo/physics-parameters","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/physics-parameters","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-simulation/ch5-gazebo/physics-parameters.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Spawning Robots in Gazebo","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/spawning-robots"},"next":{"title":"Attaching and Configuring Sensor Plugins in Gazebo","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/sensor-plugins"}}');var r=i(4848),t=i(8453);const o={},l="Tuning Physics Parameters in Gazebo",a={},c=[{value:"1. Global Physics Parameters (in the World File)",id:"1-global-physics-parameters-in-the-world-file",level:2},{value:"Key Global Parameters:",id:"key-global-parameters",level:3},{value:"2. Local Physics Parameters (in the Model File)",id:"2-local-physics-parameters-in-the-model-file",level:2},{value:"Inertial Properties (<code>&lt;inertial&gt;</code>)",id:"inertial-properties-inertial",level:3},{value:"Contact &amp; Friction Properties (<code>&lt;collision&gt;</code> and <code>&lt;surface&gt;</code>)",id:"contact--friction-properties-collision-and-surface",level:3},{value:"Joint Properties (<code>&lt;joint&gt;</code>)",id:"joint-properties-joint",level:3},{value:"A Practical Tuning Workflow",id:"a-practical-tuning-workflow",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tuning-physics-parameters-in-gazebo",children:"Tuning Physics Parameters in Gazebo"})}),"\n",(0,r.jsx)(n.p,{children:"A simulation is only as good as its physics. To create realistic and stable simulations, you must understand how to tune Gazebo's physics parameters. These settings control everything from how objects fall to how they interact upon collision."}),"\n",(0,r.jsx)(n.p,{children:"Physics parameters can be set at two levels:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Globally"})," in the World (",(0,r.jsx)(n.code,{children:".sdf"}),") file."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Locally"})," on a per-model basis within the model's SDF or URDF file."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"1-global-physics-parameters-in-the-world-file",children:"1. Global Physics Parameters (in the World File)"}),"\n",(0,r.jsxs)(n.p,{children:["Global parameters define the baseline physics for the entire simulation. They are configured within the ",(0,r.jsx)(n.code,{children:"<physics>"})," tag of your world file."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="default">\n    ...\n    <physics name="default_physics" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.81</gravity>\n      <solver>\n        <ode>\n          <solver>\n            <type>quick</type>\n            <iters>50</iters>\n            <sor>1.3</sor>\n          </solver>\n        </ode>\n      </solver>\n      <constraints>\n        <cfm>0.0</cfm>\n        <erp>0.2</erp>\n      </constraints>\n    </physics>\n    ...\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"key-global-parameters",children:"Key Global Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<gravity>"})}),": A 3D vector defining the gravitational force. The default ",(0,r.jsx)(n.code,{children:"0 0 -9.81"})," simulates Earth's gravity. Change this to simulate other planets or zero-gravity environments."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<max_step_size>"})}),": The duration of each physics update step in seconds. This is a critical parameter for stability."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Smaller values"})," (",(0,r.jsx)(n.code,{children:"0.001"})," or less) lead to higher accuracy and stability but require more computation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Larger values"})," (",(0,r.jsx)(n.code,{children:"0.01"})," or more) can make the simulation faster but may cause instability, jittering, or objects passing through each other."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rule of thumb"}),": ",(0,r.jsx)(n.code,{children:"max_step_size"})," should be ",(0,r.jsx)(n.code,{children:"1 / (10 * max_frequency)"})," of your system. For a 100 Hz robot controller, you'd want a step size of at least ",(0,r.jsx)(n.code,{children:"0.001"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<real_time_update_rate>"})}),": How often Gazebo tries to update the simulation state per second. ",(0,r.jsx)(n.code,{children:"1000"})," Hz (matching a ",(0,r.jsx)(n.code,{children:"max_step_size"})," of ",(0,r.jsx)(n.code,{children:"0.001"}),") is common. If the simulation cannot keep up, the ",(0,r.jsx)(n.code,{children:"real_time_factor"})," will drop below 1."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"<real_time_factor>"})," (RTF)"]}),": The ratio of simulation time to real time."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RTF = 1"}),": The simulation runs in real-time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RTF < 1"}),": The simulation is running slower than real-time (computationally intensive)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RTF > 1"}),": The simulation is running faster than real-time."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"<solver>"})," and ",(0,r.jsx)(n.code,{children:"<constraints>"})]}),": These are advanced settings that determine how the physics engine resolves collisions and joint limits."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"iters"})}),": The number of iterations the solver runs for each step. More iterations improve accuracy for complex contact scenarios but are slower."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"sor"})}),": Successive Over-Relaxation, a parameter for the ",(0,r.jsx)(n.code,{children:"quick"})," solver."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"cfm"})}),": Constraint Force Mixing. A small non-zero value can add compliance (softness) to joints and contacts, which can improve stability."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"erp"})}),": Error Reduction Parameter. Helps correct joint errors."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"2-local-physics-parameters-in-the-model-file",children:"2. Local Physics Parameters (in the Model File)"}),"\n",(0,r.jsx)(n.p,{children:"Local parameters are defined for each individual link and joint, allowing you to create objects with diverse physical properties."}),"\n",(0,r.jsxs)(n.h3,{id:"inertial-properties-inertial",children:["Inertial Properties (",(0,r.jsx)(n.code,{children:"<inertial>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"This is the most important property for dynamic simulation. It defines a link's mass and its resistance to rotation (moment of inertia)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<link name="my_link">\n  <inertial>\n    <mass>5.0</mass>  \x3c!-- Mass in kilograms --\x3e\n    <inertia>\n      \x3c!-- Moment of inertia matrix --\x3e\n      <ixx>0.01</ixx>\n      <ixy>0.0</ixy>\n      <ixz>0.0</ixz>\n      <iyy>0.02</iyy>\n      <iyz>0.0</iyz>\n      <izz>0.03</izz>\n    </inertia>\n  </inertial>\n  ...\n</link>\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Tuning Inertia:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Incorrect Mass"}),": If a robot link's mass is too low, it may appear \"bouncy\" or be easily knocked around. If it's too high, motors may struggle to move it."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Incorrect Inertia Matrix"}),": This is harder to intuit, but an incorrect inertia matrix will cause the link to rotate unnaturally when forces are applied. CAD software (like SolidWorks or Fusion 360) can often calculate these values for you based on the model's geometry and material density. Online calculators are also available for simple shapes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging Tip"}),": If your robot is unstable, start by increasing the mass and inertia of the base link. A stable base can solve many problems."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"contact--friction-properties-collision-and-surface",children:["Contact & Friction Properties (",(0,r.jsx)(n.code,{children:"<collision>"})," and ",(0,r.jsx)(n.code,{children:"<surface>"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["These properties define how a link interacts with other objects upon contact. They are defined within the ",(0,r.jsx)(n.code,{children:"<collision>"})," tag of a link."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<collision name="my_collision">\n  <geometry>...</geometry>\n  <surface>\n    <contact>\n      <ode>\n        <kp>1e6</kp>   \x3c!-- Stiffness --\x3e\n        <kd>100</kd>   \x3c!-- Damping --\x3e\n        <min_depth>0.001</min_depth>\n        <max_vel>1.0</max_vel>\n      </ode>\n    </contact>\n    <friction>\n      <ode>\n        <mu>0.8</mu>    \x3c!-- Coefficient of static friction --\x3e\n        <mu2>0.8</mu2>   \x3c!-- Coefficient of static friction (secondary direction) --\x3e\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Surface Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"<mu>"})," and ",(0,r.jsx)(n.code,{children:"<mu2>"})," (Friction Coefficients)"]}),": Define the force needed to make an object slide."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"0.0"}),": A frictionless surface, like ice."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"1.0"}),": A high-friction surface, like rubber on asphalt."]}),"\n",(0,r.jsxs)(n.li,{children:["Increase ",(0,r.jsx)(n.code,{children:"mu"})," for robot feet or wheels to prevent slipping. Decrease it for objects you want to slide easily."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"<kp>"})," (Stiffness)"]})," and ",(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"<kd>"})," (Damping)"]}),': These define the "springiness" of a contact.']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"kp"})," is the spring stiffness. Higher values make the contact harder."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"kd"})," is the damping. Higher values dissipate energy faster, reducing bouncing."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tuning Tip"}),': If objects are too "bouncy," increase ',(0,r.jsx)(n.code,{children:"kd"}),". If they seem to pass through each other, increase ",(0,r.jsx)(n.code,{children:"kp"}),". Finding the right balance is key to stability."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<min_depth>"})}),": The allowable penetration between surfaces before a corrective force is applied. A small value can help stabilize contacts."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"joint-properties-joint",children:["Joint Properties (",(0,r.jsx)(n.code,{children:"<joint>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Joint properties control the physics of the connections between links."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<joint name="my_joint" type="revolute">\n  ...\n  <physics>\n    <ode>\n      <limit>\n        <cfm>0.0</cfm>\n        <erp>0.2</erp>\n      </limit>\n      <damping>0.1</damping> \x3c!-- Joint damping --\x3e\n    </ode>\n  </physics>\n</joint>\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"<damping>"})}),": Simulates friction within the joint.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A small amount of damping (",(0,r.jsx)(n.code,{children:"0.1"})," to ",(0,r.jsx)(n.code,{children:"0.5"}),") is often realistic and can significantly improve the stability of a robot by preventing uncontrolled oscillations."]}),"\n",(0,r.jsx)(n.li,{children:"If a robot arm swings wildly after a movement, try increasing the damping on its joints."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"a-practical-tuning-workflow",children:"A Practical Tuning Workflow"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Start with the World"}),": Set a reasonable ",(0,r.jsx)(n.code,{children:"max_step_size"})," (e.g., ",(0,r.jsx)(n.code,{children:"0.001"}),") and Earth gravity."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Get Mass and Inertia Right"}),": Use CAD tools or calculators to get realistic inertial values for each link. When in doubt, overestimate slightly for stability."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tune Friction"}),": Set the friction for the robot's feet/wheels to a high value (e.g., ",(0,r.jsx)(n.code,{children:"0.7"})," - ",(0,r.jsx)(n.code,{children:"1.0"}),") to ensure good grip."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add Joint Damping"}),": Add a small amount of damping to all non-fixed joints to reduce oscillations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Address Instability"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Jittering?"})," Your ",(0,r.jsx)(n.code,{children:"max_step_size"})," might be too large, or ",(0,r.jsx)(n.code,{children:"kp"}),"/",(0,r.jsx)(n.code,{children:"kd"})," values for contacts are too high."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bouncing?"})," Increase the ",(0,r.jsx)(n.code,{children:"<kd>"})," (damping) on the colliding surfaces."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Passing through objects?"})," Increase ",(0,r.jsx)(n.code,{children:"<kp>"})," (stiffness) or decrease ",(0,r.jsx)(n.code,{children:"max_step_size"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Slipping?"})," Increase the friction coefficient ",(0,r.jsx)(n.code,{children:"mu"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Tuning is an iterative process. Make small changes, observe the results, and build an intuition for how each parameter affects the simulation. A well-tuned simulation is not only more realistic but also more stable and reliable for developing and testing your robotics algorithms."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);