"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[7369],{425:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-2-simulation/ch5-gazebo/gazebo-architecture","title":"Gazebo Architecture","description":"Learn the fundamental components of Gazebo simulation: worlds, models, plugins, and how they interact to create realistic robot simulations.","source":"@site/docs/module-2-simulation/ch5-gazebo/gazebo-architecture.md","sourceDirName":"module-2-simulation/ch5-gazebo","slug":"/module-2-simulation/ch5-gazebo/gazebo-architecture","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/gazebo-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-simulation/ch5-gazebo/gazebo-architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 1 Assessment: Build a Robot Control System","permalink":"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch4-packages/assessment"},"next":{"title":"Spawning Robots in Gazebo","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/spawning-robots"}}');var l=s(4848),r=s(8453);const o={},t="Gazebo Architecture",a={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:2},{value:"Gazebo Architecture Overview",id:"gazebo-architecture-overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"1. World",id:"1-world",level:3},{value:"2. Models",id:"2-models",level:3},{value:"3. Plugins",id:"3-plugins",level:3},{value:"4. Physics Engine",id:"4-physics-engine",level:3},{value:"SDF vs URDF",id:"sdf-vs-urdf",level:2},{value:"Gazebo GUI Components",id:"gazebo-gui-components",level:2},{value:"Scene View (Center)",id:"scene-view-center",level:3},{value:"World Panel (Left)",id:"world-panel-left",level:3},{value:"Model Editor (Optional)",id:"model-editor-optional",level:3},{value:"Time Panel (Bottom)",id:"time-panel-bottom",level:3},{value:"How Gazebo Integrates with ROS 2",id:"how-gazebo-integrates-with-ros-2",level:2},{value:"Launching Gazebo with ROS 2",id:"launching-gazebo-with-ros-2",level:2},{value:"Method 1: Launch Gazebo alone",id:"method-1-launch-gazebo-alone",level:3},{value:"Method 2: Launch Gazebo from ROS 2 launch file",id:"method-2-launch-gazebo-from-ros-2-launch-file",level:3},{value:"Method 3: Spawn robot in running Gazebo",id:"method-3-spawn-robot-in-running-gazebo",level:3},{value:"Understanding Simulation Time",id:"understanding-simulation-time",level:2},{value:"Common Gazebo Workflows",id:"common-gazebo-workflows",level:2},{value:"1. Testing a Robot URDF",id:"1-testing-a-robot-urdf",level:3},{value:"2. Building a Custom World",id:"2-building-a-custom-world",level:3},{value:"3. Adding Sensors to Existing Model",id:"3-adding-sensors-to-existing-model",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Debugging Simulation Issues",id:"debugging-simulation-issues",level:3},{value:"Organizing Gazebo Files",id:"organizing-gazebo-files",level:3},{value:"Check Your Understanding",id:"check-your-understanding",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"gazebo-architecture",children:"Gazebo Architecture"})}),"\n",(0,l.jsx)(n.p,{children:"Learn the fundamental components of Gazebo simulation: worlds, models, plugins, and how they interact to create realistic robot simulations."}),"\n",(0,l.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,l.jsx)(n.p,{children:"By the end of this lesson, you will:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Understand Gazebo's architecture and core components"}),"\n",(0,l.jsx)(n.li,{children:"Know the difference between worlds, models, and plugins"}),"\n",(0,l.jsx)(n.li,{children:"Understand how Gazebo integrates with ROS 2"}),"\n",(0,l.jsx)(n.li,{children:"Be able to navigate the Gazebo GUI and understand simulation concepts"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["ROS 2 Humble installed (",(0,l.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch1-fundamentals/installation",children:"Installation Guide"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:["Basic understanding of URDF (",(0,l.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch3-urdf/urdf-syntax",children:"URDF Syntax"}),")"]}),"\n",(0,l.jsx)(n.li,{children:"Familiarity with ROS 2 topics and nodes"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Gazebo"})," is an open-source 3D robotics simulator that provides:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Realistic physics"}),": Gravity, friction, inertia, collisions"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Sensor simulation"}),": LiDAR, cameras, IMUs, GPS"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ROS 2 integration"}),": Seamless communication with ROS 2 nodes"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Visualization"}),": 3D rendering of robots and environments"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Plugin system"}),": Extensible architecture for custom behaviors"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Gazebo is the industry-standard simulator for ROS robotics development, used by researchers, students, and companies worldwide."}),"\n",(0,l.jsx)(n.h2,{id:"gazebo-architecture-overview",children:"Gazebo Architecture Overview"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mermaid",children:"graph TB\n    A[Gazebo Simulation] --\x3e B[World]\n    A --\x3e C[Models]\n    A --\x3e D[Plugins]\n    A --\x3e E[Physics Engine]\n\n    B --\x3e F[Environment]\n    B --\x3e G[Lighting]\n    B --\x3e H[Physics Settings]\n\n    C --\x3e I[Links]\n    C --\x3e J[Joints]\n    C --\x3e K[Sensors]\n\n    D --\x3e L[Model Plugins]\n    D --\x3e M[Sensor Plugins]\n    D --\x3e N[World Plugins]\n\n    E --\x3e O[ODE/Bullet/DART]\n\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style C fill:#ffe1f5\n    style D fill:#e1ffe1\n"})}),"\n",(0,l.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,l.jsx)(n.h3,{id:"1-world",children:"1. World"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.strong,{children:"world"})," is the top-level container for your simulation."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"What it contains:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Environment definition (ground plane, sky, lighting)"}),"\n",(0,l.jsx)(n.li,{children:"Physics engine configuration (gravity, solver settings)"}),"\n",(0,l.jsx)(n.li,{children:"Global simulation parameters (real-time factor, step size)"}),"\n",(0,l.jsx)(n.li,{children:"References to all models in the scene"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example world structure (SDF):"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.8">\n  <world name="my_world">\n    \x3c!-- Physics engine settings --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>1 1 1 1</diffuse>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Key world parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gravity"}),": Gravitational acceleration (default: 0 0 -9.81)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max_step_size"}),": Simulation time step (default: 0.001s = 1ms)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"real_time_factor"}),": How fast to run simulation (1.0 = real-time)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"2-models",children:"2. Models"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Models"})," are the objects in your simulation (robots, obstacles, furniture)."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"What they contain:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Links"}),": Rigid bodies with mass, inertia, collision geometry"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Joints"}),": Connections between links (revolute, prismatic, fixed)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Sensors"}),": Cameras, LiDAR, IMU attached to links"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Plugins"}),": Custom behaviors and control logic"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Model hierarchy:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'Model (e.g., "my_robot")\n\u251c\u2500\u2500 Link 1 (e.g., "base_link")\n\u2502   \u251c\u2500\u2500 Visual (appearance)\n\u2502   \u251c\u2500\u2500 Collision (physics)\n\u2502   \u2514\u2500\u2500 Inertial (mass, inertia)\n\u251c\u2500\u2500 Link 2 (e.g., "wheel_left")\n\u251c\u2500\u2500 Joint 1 (connects Link 1 \u2194 Link 2)\n\u2514\u2500\u2500 Sensor 1 (e.g., "camera")\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example model snippet:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<model name="simple_box">\n  <link name="box_link">\n    <pose>0 0 0.5 0 0 0</pose>\n\n    \x3c!-- Visual appearance --\x3e\n    <visual name="visual">\n      <geometry>\n        <box><size>1 1 1</size></box>\n      </geometry>\n    </visual>\n\n    \x3c!-- Collision shape --\x3e\n    <collision name="collision">\n      <geometry>\n        <box><size>1 1 1</size></box>\n      </geometry>\n    </collision>\n\n    \x3c!-- Physical properties --\x3e\n    <inertial>\n      <mass>10.0</mass>\n      <inertia>\n        <ixx>1.67</ixx>\n        <iyy>1.67</iyy>\n        <izz>1.67</izz>\n      </inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,l.jsx)(n.h3,{id:"3-plugins",children:"3. Plugins"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Plugins"})," extend Gazebo's functionality with custom code."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Three types of plugins:"})}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Plugin Type"}),(0,l.jsx)(n.th,{children:"Purpose"}),(0,l.jsx)(n.th,{children:"Example Use Cases"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"World Plugins"})}),(0,l.jsx)(n.td,{children:"Global behaviors, environment control"}),(0,l.jsx)(n.td,{children:"Wind simulation, dynamic lighting"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Model Plugins"})}),(0,l.jsx)(n.td,{children:"Robot control, actuators"}),(0,l.jsx)(n.td,{children:"Wheel controllers, arm manipulation"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Sensor Plugins"})}),(0,l.jsx)(n.td,{children:"Sensor data processing, publishing"}),(0,l.jsx)(n.td,{children:"Camera \u2192 ROS topic, LiDAR filtering"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Example: Model plugin for differential drive"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<plugin name="differential_drive" filename="libgazebo_ros_diff_drive.so">\n  <ros>\n    <namespace>/my_robot</namespace>\n  </ros>\n\n  <left_joint>wheel_left_joint</left_joint>\n  <right_joint>wheel_right_joint</right_joint>\n\n  <wheel_separation>0.5</wheel_separation>\n  <wheel_diameter>0.2</wheel_diameter>\n\n  <publish_odom>true</publish_odom>\n  <publish_odom_tf>true</publish_odom_tf>\n\n  <odometry_topic>odom</odometry_topic>\n  <odometry_frame>odom</odometry_frame>\n  <robot_base_frame>base_link</robot_base_frame>\n</plugin>\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Common Gazebo ROS 2 plugins:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"libgazebo_ros_diff_drive.so"}),": Differential drive controller"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"libgazebo_ros_joint_state_publisher.so"}),": Publishes joint states"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"libgazebo_ros_camera.so"}),": Camera sensor"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"libgazebo_ros_ray_sensor.so"}),": LiDAR sensor"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"libgazebo_ros_imu_sensor.so"}),": IMU sensor"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"4-physics-engine",children:"4. Physics Engine"}),"\n",(0,l.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Engine"}),(0,l.jsx)(n.th,{children:"Pros"}),(0,l.jsx)(n.th,{children:"Cons"}),(0,l.jsx)(n.th,{children:"Best For"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsxs)(n.td,{children:[(0,l.jsx)(n.strong,{children:"ODE"})," (default)"]}),(0,l.jsx)(n.td,{children:"Fast, stable, well-tested"}),(0,l.jsx)(n.td,{children:"Less accurate contacts"}),(0,l.jsx)(n.td,{children:"Mobile robots, general use"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Bullet"})}),(0,l.jsx)(n.td,{children:"Good contact dynamics"}),(0,l.jsx)(n.td,{children:"Slower than ODE"}),(0,l.jsx)(n.td,{children:"Manipulation, grasping"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"DART"})}),(0,l.jsx)(n.td,{children:"Advanced constraints, stable"}),(0,l.jsx)(n.td,{children:"Newer, less tested"}),(0,l.jsx)(n.td,{children:"Complex mechanisms"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Physics configuration:"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <real_time_update_rate>1000</real_time_update_rate>\n\n  <ode>\n    <solver>\n      <type>quick</type>\n      <iters>50</iters>\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Key physics parameters:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"max_step_size"}),": Smaller = more accurate but slower (0.001s is good default)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"real_time_factor"}),": >1.0 = faster than real-time, <1.0 = slower"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"iters"}),": Solver iterations (higher = more accurate but slower)"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"sdf-vs-urdf",children:"SDF vs URDF"}),"\n",(0,l.jsxs)(n.p,{children:["Gazebo uses ",(0,l.jsx)(n.strong,{children:"SDF (Simulation Description Format)"}),", not URDF directly."]}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Feature"}),(0,l.jsx)(n.th,{children:"URDF"}),(0,l.jsx)(n.th,{children:"SDF"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Purpose"})}),(0,l.jsx)(n.td,{children:"Robot description for ROS"}),(0,l.jsx)(n.td,{children:"Simulation worlds and models"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Flexibility"})}),(0,l.jsx)(n.td,{children:"Limited to robot kinematics"}),(0,l.jsx)(n.td,{children:"Full simulation scenes"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Physics"})}),(0,l.jsx)(n.td,{children:"Basic (mass, inertia)"}),(0,l.jsx)(n.td,{children:"Advanced (friction, damping, contacts)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Sensors"})}),(0,l.jsx)(n.td,{children:"Not supported"}),(0,l.jsx)(n.td,{children:"Full sensor definitions"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Gazebo Support"})}),(0,l.jsx)(n.td,{children:"Converted to SDF internally"}),(0,l.jsx)(n.td,{children:"Native format"})]})]})]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Good news"}),": You can use URDF files in Gazebo! They're automatically converted to SDF."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"When to use each:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"URDF"}),": Robot description, ROS 2 packages, simple models"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"SDF"}),": Complex worlds, advanced physics, multiple robots"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"gazebo-gui-components",children:"Gazebo GUI Components"}),"\n",(0,l.jsx)(n.p,{children:"When you launch Gazebo, you see several panels:"}),"\n",(0,l.jsx)(n.h3,{id:"scene-view-center",children:"Scene View (Center)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"3D visualization of world"}),"\n",(0,l.jsx)(n.li,{children:"Camera controls: Rotate (drag), Pan (Shift+drag), Zoom (scroll)"}),"\n",(0,l.jsx)(n.li,{children:"Selection tool: Click objects to inspect"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"world-panel-left",children:"World Panel (Left)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Tree view of all models and lights"}),"\n",(0,l.jsx)(n.li,{children:"Insert models from library"}),"\n",(0,l.jsx)(n.li,{children:"Adjust model poses"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"model-editor-optional",children:"Model Editor (Optional)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Visual model builder"}),"\n",(0,l.jsx)(n.li,{children:"Link/joint creation"}),"\n",(0,l.jsx)(n.li,{children:"Save custom models"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"time-panel-bottom",children:"Time Panel (Bottom)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Play/Pause simulation"}),"\n",(0,l.jsx)(n.li,{children:"Real-time factor (actual speed vs wall-clock time)"}),"\n",(0,l.jsx)(n.li,{children:"Simulation time vs real time"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"how-gazebo-integrates-with-ros-2",children:"How Gazebo Integrates with ROS 2"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant ROS as ROS 2 Node\n    participant Bridge as gazebo_ros\n    participant Gazebo as Gazebo Simulation\n    participant Physics as Physics Engine\n\n    ROS->>Bridge: /cmd_vel (Twist)\n    Bridge->>Gazebo: Apply forces to joints\n    Gazebo->>Physics: Update simulation\n    Physics->>Gazebo: New robot state\n    Gazebo->>Bridge: Joint states, sensor data\n    Bridge->>ROS: /joint_states, /scan, /odom\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Key integration points:"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Command topics"})," (ROS \u2192 Gazebo): ",(0,l.jsx)(n.code,{children:"/cmd_vel"}),", ",(0,l.jsx)(n.code,{children:"/joint_commands"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Sensor topics"})," (Gazebo \u2192 ROS): ",(0,l.jsx)(n.code,{children:"/scan"}),", ",(0,l.jsx)(n.code,{children:"/camera/image_raw"}),", ",(0,l.jsx)(n.code,{children:"/imu"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"State topics"})," (Gazebo \u2192 ROS): ",(0,l.jsx)(n.code,{children:"/joint_states"}),", ",(0,l.jsx)(n.code,{children:"/odom"}),", ",(0,l.jsx)(n.code,{children:"/tf"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Services"})," (ROS \u2194 Gazebo): ",(0,l.jsx)(n.code,{children:"/spawn_entity"}),", ",(0,l.jsx)(n.code,{children:"/delete_entity"})]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsxs)(n.strong,{children:["The ",(0,l.jsx)(n.code,{children:"gazebo_ros"})," package"]})," provides:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"spawn_entity.py"}),": Load URDF/SDF models into running simulation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gazebo_ros_state"}),": Publish model states"]}),"\n",(0,l.jsx)(n.li,{children:"ROS 2 plugins for sensors and actuators"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"launching-gazebo-with-ros-2",children:"Launching Gazebo with ROS 2"}),"\n",(0,l.jsx)(n.h3,{id:"method-1-launch-gazebo-alone",children:"Method 1: Launch Gazebo alone"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# Launch Gazebo with empty world\ngazebo --verbose\n\n# Launch with specific world file\ngazebo worlds/my_world.sdf\n"})}),"\n",(0,l.jsx)(n.h3,{id:"method-2-launch-gazebo-from-ros-2-launch-file",children:"Method 2: Launch Gazebo from ROS 2 launch file"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            FindPackageShare('gazebo_ros'),\n            '/launch/gazebo.launch.py'\n        ]),\n        launch_arguments={'world': 'my_world.sdf'}.items()\n    )\n\n    return LaunchDescription([gazebo])\n"})}),"\n",(0,l.jsx)(n.h3,{id:"method-3-spawn-robot-in-running-gazebo",children:"Method 3: Spawn robot in running Gazebo"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# Terminal 1: Start Gazebo\nros2 launch gazebo_ros gazebo.launch.py\n\n# Terminal 2: Spawn robot from URDF\nros2 run gazebo_ros spawn_entity.py -entity my_robot -file my_robot.urdf\n"})}),"\n",(0,l.jsx)(n.h2,{id:"understanding-simulation-time",children:"Understanding Simulation Time"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Simulation time"})," \u2260 ",(0,l.jsx)(n.strong,{children:"Real time"})," (wall-clock time)"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Real-time factor (RTF)"}),": How fast simulation runs compared to reality"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"RTF = 1.0 \u2192 1 second of simulation = 1 second of real time"}),"\n",(0,l.jsx)(n.li,{children:"RTF = 0.5 \u2192 Simulation runs at half speed (slow motion)"}),"\n",(0,l.jsx)(n.li,{children:"RTF = 2.0 \u2192 Simulation runs twice as fast (if your computer can handle it)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Step size"}),": How much simulation time advances per iteration"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Default: 0.001s (1ms)"}),"\n",(0,l.jsx)(n.li,{children:"Smaller step = more accurate but slower"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Why simulation might run slower than real-time:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Complex physics calculations"}),"\n",(0,l.jsx)(n.li,{children:"Many contacts/collisions"}),"\n",(0,l.jsx)(n.li,{children:"High-resolution sensors (cameras, LiDAR)"}),"\n",(0,l.jsx)(n.li,{children:"CPU limitations"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Tip"}),": Monitor RTF in Gazebo GUI bottom panel. If RTF < 1.0, simulation is struggling."]}),"\n",(0,l.jsx)(n.h2,{id:"common-gazebo-workflows",children:"Common Gazebo Workflows"}),"\n",(0,l.jsx)(n.h3,{id:"1-testing-a-robot-urdf",children:"1. Testing a Robot URDF"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# Convert URDF to SDF and inspect\ngz sdf -p my_robot.urdf\n\n# Launch in Gazebo\nros2 launch gazebo_ros gazebo.launch.py\nros2 run gazebo_ros spawn_entity.py -entity test_robot -file my_robot.urdf\n"})}),"\n",(0,l.jsx)(n.h3,{id:"2-building-a-custom-world",children:"2. Building a Custom World"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Create ",(0,l.jsx)(n.code,{children:".sdf"})," file with world definition"]}),"\n",(0,l.jsx)(n.li,{children:"Add ground plane, lighting, obstacles"}),"\n",(0,l.jsx)(n.li,{children:"Configure physics parameters"}),"\n",(0,l.jsxs)(n.li,{children:["Launch: ",(0,l.jsx)(n.code,{children:"gazebo my_world.sdf"})]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"3-adding-sensors-to-existing-model",children:"3. Adding Sensors to Existing Model"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Edit model SDF"}),"\n",(0,l.jsxs)(n.li,{children:["Add sensor definition under ",(0,l.jsx)(n.code,{children:"<link>"})]}),"\n",(0,l.jsxs)(n.li,{children:["Add sensor plugin (e.g., ",(0,l.jsx)(n.code,{children:"libgazebo_ros_camera.so"}),")"]}),"\n",(0,l.jsx)(n.li,{children:"Reload model in Gazebo"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Use appropriate step size"}),": 0.001s is good default"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Limit real-time factor"}),": Don't try to run faster than your CPU allows"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Simplify collision geometry"}),": Use primitive shapes (boxes, cylinders) instead of meshes"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Reduce sensor update rates"}),": Cameras at 10-30 Hz, LiDAR at 10 Hz is usually sufficient"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Disable shadows"})," for faster rendering: Edit \u2192 View \u2192 Shadows (uncheck)"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"debugging-simulation-issues",children:"Debugging Simulation Issues"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Check physics stability"}),": If robot jitters or explodes, reduce step size"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Inspect contacts"}),": View \u2192 Contacts to see collision points"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Verify inertia"}),": Use ",(0,l.jsx)(n.code,{children:"check_urdf"})," or Gazebo model editor"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Monitor RTF"}),": If < 0.5, simplify physics or models"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"organizing-gazebo-files",children:"Organizing Gazebo Files"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"my_robot_gazebo/\n\u251c\u2500\u2500 worlds/\n\u2502   \u251c\u2500\u2500 empty.sdf\n\u2502   \u2514\u2500\u2500 warehouse.sdf\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 my_robot/\n\u2502       \u251c\u2500\u2500 model.sdf\n\u2502       \u2514\u2500\u2500 meshes/\n\u251c\u2500\u2500 launch/\n\u2502   \u2514\u2500\u2500 gazebo.launch.py\n\u2514\u2500\u2500 config/\n    \u2514\u2500\u2500 gazebo_params.yaml\n"})}),"\n",(0,l.jsx)(n.h2,{id:"check-your-understanding",children:"Check Your Understanding"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"What are the three main types of Gazebo plugins?"})}),"\n",(0,l.jsx)(s,{children:(0,l.jsxs)(n.p,{children:[(0,l.jsx)("summary",{children:"Answer"}),"\nWorld plugins (global behaviors), Model plugins (robot control), Sensor plugins (sensor data processing and publishing)."]})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"What's the difference between URDF and SDF?"})}),"\n",(0,l.jsx)(s,{children:(0,l.jsxs)(n.p,{children:[(0,l.jsx)("summary",{children:"Answer"}),"\nURDF is for robot kinematics (ROS-focused), while SDF is for full simulation scenes with advanced physics, sensors, and multiple models. Gazebo converts URDF to SDF internally."]})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"If your simulation real-time factor (RTF) is 0.5, what does that mean?"})}),"\n",(0,l.jsx)(s,{children:(0,l.jsxs)(n.p,{children:[(0,l.jsx)("summary",{children:"Answer"}),"\nThe simulation is running at half speed - it takes 2 seconds of real time to simulate 1 second. This indicates the physics/rendering is too complex for your CPU."]})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Why use collision geometry simpler than visual meshes?"})}),"\n",(0,l.jsx)(s,{children:(0,l.jsxs)(n.p,{children:[(0,l.jsx)("summary",{children:"Answer"}),"\nPhysics calculations on complex meshes are very slow. Using primitive shapes (boxes, cylinders, spheres) for collision while keeping detailed meshes for visuals dramatically improves performance."]})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Gazebo architecture"}),": World contains models with links, joints, sensors, and plugins"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"SDF format"}),": Native Gazebo format, more powerful than URDF for simulation"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Physics engines"}),": ODE (default, fast), Bullet (contacts), DART (advanced)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Plugins enable ROS 2 integration"}),": Sensors publish to topics, actuators subscribe to commands"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Step size and RTF"}),": Balance accuracy (small step) vs speed (high RTF)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"URDF works in Gazebo"}),": Automatically converted to SDF"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,l.jsx)(n.p,{children:"Now that you understand Gazebo's architecture:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Next Lesson"}),": ",(0,l.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/spawning-robots",children:"Spawning Robots in Gazebo"})," - Load URDF/SDF models"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Related"}),": ",(0,l.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/physics-parameters",children:"Physics Parameters"})," - Tune gravity, friction, contacts"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Advanced"}),": ",(0,l.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/sensor-plugins",children:"Sensor Plugins"})," - Add LiDAR, cameras, IMU"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://gazebosim.org/docs",children:"Gazebo Official Documentation"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"http://sdformat.org/",children:"SDF Format Specification"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"Gazebo ROS 2 Integration"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.a,{href:"https://gazebosim.org/api/gazebo/6/physics.html",children:"Understanding Physics Engines"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>t});var i=s(6540);const l={},r=i.createContext(l);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);