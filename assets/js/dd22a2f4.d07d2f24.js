"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[4880],{2152:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"module-1-ros2/ch2-python-rclpy/timers-callbacks","title":"Timers and Callbacks in ROS 2","description":"Introduction","source":"@site/docs/module-1-ros2/ch2-python-rclpy/timers-callbacks.md","sourceDirName":"module-1-ros2/ch2-python-rclpy","slug":"/module-1-ros2/ch2-python-rclpy/timers-callbacks","permalink":"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch2-python-rclpy/timers-callbacks","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-1-ros2/ch2-python-rclpy/timers-callbacks.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Message Types","permalink":"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch2-python-rclpy/message-types"},"next":{"title":"ROS 2 Parameters","permalink":"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch2-python-rclpy/parameters"}}');var i=s(4848),a=s(8453);const t={},r="Timers and Callbacks in ROS 2",c={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding the Event Loop",id:"understanding-the-event-loop",level:2},{value:"Creating Timers",id:"creating-timers",level:2},{value:"Basic Timer",id:"basic-timer",level:3},{value:"Timer with Different Periods",id:"timer-with-different-periods",level:3},{value:"Subscription Callbacks",id:"subscription-callbacks",level:2},{value:"Combining Timers and Subscriptions",id:"combining-timers-and-subscriptions",level:2},{value:"Pattern 1: Process on Timer, Publish Latest Data",id:"pattern-1-process-on-timer-publish-latest-data",level:3},{value:"Pattern 2: State Machine with Timer",id:"pattern-2-state-machine-with-timer",level:3},{value:"Lambda Functions as Callbacks",id:"lambda-functions-as-callbacks",level:2},{value:"Callback Groups and Parallel Execution",id:"callback-groups-and-parallel-execution",level:2},{value:"Sequential Execution (Default)",id:"sequential-execution-default",level:3},{value:"Parallel Execution with Callback Groups",id:"parallel-execution-with-callback-groups",level:3},{value:"Callback Group Types",id:"callback-group-types",level:3},{value:"Managing Callback Timing",id:"managing-callback-timing",level:2},{value:"Measuring Execution Time",id:"measuring-execution-time",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Canceling and Resetting Timers",id:"canceling-and-resetting-timers",level:2},{value:"Canceling a Timer",id:"canceling-a-timer",level:3},{value:"Creating One-Shot Timers",id:"creating-one-shot-timers",level:3},{value:"Error Handling in Callbacks",id:"error-handling-in-callbacks",level:2},{value:"Try-Except Pattern",id:"try-except-pattern",level:3},{value:"Defensive Programming",id:"defensive-programming",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Callbacks Short and Fast",id:"1-keep-callbacks-short-and-fast",level:3},{value:"2. Use Timers for Periodic Tasks",id:"2-use-timers-for-periodic-tasks",level:3},{value:"3. Store Latest Data, Process on Schedule",id:"3-store-latest-data-process-on-schedule",level:3},{value:"4. Log at Appropriate Levels",id:"4-log-at-appropriate-levels",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Exercise 1: Multi-Rate Publishing",id:"exercise-1-multi-rate-publishing",level:3},{value:"Exercise 2: Sensor Fusion",id:"exercise-2-sensor-fusion",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"timers-and-callbacks-in-ros-2",children:"Timers and Callbacks in ROS 2"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Callbacks are the heart of event-driven programming in ROS 2. Understanding how to use timers and callbacks effectively enables you to build responsive, efficient robotic systems. This lesson covers timer creation, callback execution, and advanced patterns for managing multiple callbacks."}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create and manage timers in ROS 2 nodes"}),"\n",(0,i.jsx)(n.li,{children:"Understand callback execution and the event loop"}),"\n",(0,i.jsx)(n.li,{children:"Handle multiple callbacks efficiently"}),"\n",(0,i.jsx)(n.li,{children:"Implement callback groups for parallel execution"}),"\n",(0,i.jsx)(n.li,{children:"Debug callback timing issues"}),"\n",(0,i.jsx)(n.li,{children:"Use best practices for callback design"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'Completed "First ROS 2 Node" lesson'}),"\n",(0,i.jsx)(n.li,{children:"Understanding of ROS 2 publishers and subscribers"}),"\n",(0,i.jsx)(n.li,{children:"Basic Python knowledge including functions and classes"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"understanding-the-event-loop",children:"Understanding the Event Loop"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 uses an event-driven architecture:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         rclpy.spin(node)            \u2502\n\u2502         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500            \u2502\n\u2502                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Wait for Events             \u2502 \u2502\n\u2502  \u2502   - Timer expires             \u2502 \u2502\n\u2502  \u2502   - Message arrives           \u2502 \u2502\n\u2502  \u2502   - Service called            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                      \u2502\n\u2502              \u2193                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Execute Callback            \u2502 \u2502\n\u2502  \u2502   - Process event             \u2502 \u2502\n\u2502  \u2502   - Return to waiting         \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502              \u2502                      \u2502\n\u2502              \u2193                      \u2502\n\u2502         (repeat)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rclpy.spin()"})," runs an infinite loop"]}),"\n",(0,i.jsx)(n.li,{children:"Blocks until an event occurs"}),"\n",(0,i.jsx)(n.li,{children:"Executes the associated callback"}),"\n",(0,i.jsx)(n.li,{children:"Returns to waiting for next event"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"creating-timers",children:"Creating Timers"}),"\n",(0,i.jsx)(n.h3,{id:"basic-timer",children:"Basic Timer"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\n\nclass TimerNode(Node):\n    def __init__(self):\n        super().__init__('timer_node')\n\n        # Create timer that fires every 1.0 seconds\n        self.timer = self.create_timer(\n            timer_period_sec=1.0,\n            callback=self.timer_callback\n        )\n        self.counter = 0\n\n    def timer_callback(self):\n        self.get_logger().info(f'Timer fired: {self.counter}')\n        self.counter += 1\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TimerNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"timer-with-different-periods",children:"Timer with Different Periods"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class MultiTimerNode(Node):\n    def __init__(self):\n        super().__init__('multi_timer_node')\n\n        # Fast timer (10 Hz)\n        self.fast_timer = self.create_timer(0.1, self.fast_callback)\n\n        # Medium timer (1 Hz)\n        self.medium_timer = self.create_timer(1.0, self.medium_callback)\n\n        # Slow timer (0.2 Hz)\n        self.slow_timer = self.create_timer(5.0, self.slow_callback)\n\n    def fast_callback(self):\n        self.get_logger().debug('Fast: 10 Hz')\n\n    def medium_callback(self):\n        self.get_logger().info('Medium: 1 Hz')\n\n    def slow_callback(self):\n        self.get_logger().warn('Slow: 0.2 Hz')\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"subscription-callbacks",children:"Subscription Callbacks"}),"\n",(0,i.jsx)(n.p,{children:"Callbacks are automatically called when messages arrive:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\n\nclass SubscriberNode(Node):\n    def __init__(self):\n        super().__init__('subscriber_node')\n\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,  # Callback function\n            10\n        )\n\n    def listener_callback(self, msg):\n        # This is called automatically when a message arrives\n        self.get_logger().info(f'Received: {msg.data}')\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Callback Signature:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def listener_callback(self, msg: MessageType):\n    # msg is the received message\n    # Use msg.field_name to access data\n    pass\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"combining-timers-and-subscriptions",children:"Combining Timers and Subscriptions"}),"\n",(0,i.jsx)(n.h3,{id:"pattern-1-process-on-timer-publish-latest-data",children:"Pattern 1: Process on Timer, Publish Latest Data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\n\n\nclass SensorProcessor(Node):\n    def __init__(self):\n        super().__init__('sensor_processor')\n\n        # Subscribe to sensor\n        self.subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.scan_callback,\n            10\n        )\n\n        # Publish processed result on timer\n        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.timer = self.create_timer(0.1, self.control_loop)\n\n        self.latest_scan = None\n\n    def scan_callback(self, msg):\n        # Store latest scan data\n        self.latest_scan = msg\n\n    def control_loop(self):\n        # Process latest scan and publish command\n        if self.latest_scan is not None:\n            cmd = self.compute_velocity(self.latest_scan)\n            self.publisher.publish(cmd)\n\n    def compute_velocity(self, scan):\n        # Example: Simple obstacle avoidance\n        cmd = Twist()\n\n        # Get minimum distance\n        if scan.ranges:\n            min_dist = min(scan.ranges)\n\n            if min_dist < 1.0:\n                # Too close, stop\n                cmd.linear.x = 0.0\n            else:\n                # Move forward\n                cmd.linear.x = 0.5\n\n        return cmd\n"})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-2-state-machine-with-timer",children:"Pattern 2: State Machine with Timer"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from enum import Enum\n\n\nclass RobotState(Enum):\n    IDLE = 0\n    MOVING = 1\n    TURNING = 2\n    STOPPED = 3\n\n\nclass StateMachineNode(Node):\n    def __init__(self):\n        super().__init__('state_machine_node')\n\n        self.state = RobotState.IDLE\n        self.timer = self.create_timer(0.1, self.state_machine_callback)\n        self.state_entry_time = self.get_clock().now()\n\n    def state_machine_callback(self):\n        current_time = self.get_clock().now()\n\n        if self.state == RobotState.IDLE:\n            # Stay idle for 2 seconds, then move\n            if (current_time - self.state_entry_time).nanoseconds > 2e9:\n                self.transition_to(RobotState.MOVING)\n\n        elif self.state == RobotState.MOVING:\n            # Move for 5 seconds, then turn\n            self.get_logger().info('Moving forward...')\n            if (current_time - self.state_entry_time).nanoseconds > 5e9:\n                self.transition_to(RobotState.TURNING)\n\n        elif self.state == RobotState.TURNING:\n            # Turn for 2 seconds, then stop\n            self.get_logger().info('Turning...')\n            if (current_time - self.state_entry_time).nanoseconds > 2e9:\n                self.transition_to(RobotState.STOPPED)\n\n        elif self.state == RobotState.STOPPED:\n            self.get_logger().info('Stopped')\n\n    def transition_to(self, new_state):\n        self.get_logger().info(f'State: {self.state.name} -> {new_state.name}')\n        self.state = new_state\n        self.state_entry_time = self.get_clock().now()\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"lambda-functions-as-callbacks",children:"Lambda Functions as Callbacks"}),"\n",(0,i.jsx)(n.p,{children:"You can use lambda functions for simple callbacks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class LambdaNode(Node):\n    def __init__(self):\n        super().__init__('lambda_node')\n\n        # Using lambda for simple timer\n        self.timer = self.create_timer(\n            1.0,\n            lambda: self.get_logger().info('Lambda timer fired')\n        )\n\n        # Using lambda with counter (requires careful state management)\n        self.counter = 0\n        self.timer2 = self.create_timer(\n            2.0,\n            lambda: self.increment_and_log()\n        )\n\n    def increment_and_log(self):\n        self.counter += 1\n        self.get_logger().info(f'Count: {self.counter}')\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," For complex logic, use named methods instead of lambdas."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"callback-groups-and-parallel-execution",children:"Callback Groups and Parallel Execution"}),"\n",(0,i.jsx)(n.p,{children:"By default, all callbacks execute sequentially. Use callback groups for parallel execution:"}),"\n",(0,i.jsx)(n.h3,{id:"sequential-execution-default",children:"Sequential Execution (Default)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class SequentialNode(Node):\n    def __init__(self):\n        super().__init__('sequential_node')\n\n        # These callbacks will NEVER run simultaneously\n        self.timer1 = self.create_timer(0.1, self.callback1)\n        self.timer2 = self.create_timer(0.1, self.callback2)\n\n    def callback1(self):\n        # If this takes 1 second, callback2 must wait\n        self.get_logger().info('Callback 1 start')\n        time.sleep(1.0)\n        self.get_logger().info('Callback 1 end')\n\n    def callback2(self):\n        self.get_logger().info('Callback 2')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parallel-execution-with-callback-groups",children:"Parallel Execution with Callback Groups"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\n\n\nclass ParallelNode(Node):\n    def __init__(self):\n        super().__init__('parallel_node')\n\n        # Create separate callback groups\n        self.group1 = MutuallyExclusiveCallbackGroup()\n        self.group2 = MutuallyExclusiveCallbackGroup()\n\n        # Assign timers to different groups\n        self.timer1 = self.create_timer(\n            0.1,\n            self.callback1,\n            callback_group=self.group1\n        )\n\n        self.timer2 = self.create_timer(\n            0.1,\n            self.callback2,\n            callback_group=self.group2\n        )\n\n    def callback1(self):\n        self.get_logger().info('Callback 1 start')\n        time.sleep(1.0)\n        self.get_logger().info('Callback 1 end')\n\n    def callback2(self):\n        # This CAN run while callback1 is sleeping\n        self.get_logger().info('Callback 2')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ParallelNode()\n\n    # Use MultiThreadedExecutor for parallel execution\n    executor = MultiThreadedExecutor()\n    executor.add_node(node)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"callback-group-types",children:"Callback Group Types"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Behavior"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"MutuallyExclusiveCallbackGroup"})}),(0,i.jsx)(n.td,{children:"Only one callback in the group executes at a time"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ReentrantCallbackGroup"})}),(0,i.jsx)(n.td,{children:"Multiple callbacks in the group can run simultaneously"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"managing-callback-timing",children:"Managing Callback Timing"}),"\n",(0,i.jsx)(n.h3,{id:"measuring-execution-time",children:"Measuring Execution Time"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class TimingNode(Node):\n    def __init__(self):\n        super().__init__('timing_node')\n        self.timer = self.create_timer(0.1, self.timed_callback)\n\n    def timed_callback(self):\n        start_time = self.get_clock().now()\n\n        # Do work\n        self.do_expensive_computation()\n\n        end_time = self.get_clock().now()\n        duration = (end_time - start_time).nanoseconds / 1e6  # Convert to ms\n\n        self.get_logger().info(f'Callback took {duration:.2f} ms')\n\n    def do_expensive_computation(self):\n        # Simulate work\n        result = sum(range(10000))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class RateLimitedNode(Node):\n    def __init__(self):\n        super().__init__('rate_limited_node')\n\n        # Fast subscription\n        self.subscription = self.create_subscription(\n            String,\n            'fast_topic',\n            self.fast_callback,\n            100  # Large queue\n        )\n\n        # Slow publisher (1 Hz)\n        self.publisher = self.create_publisher(String, 'slow_topic', 10)\n        self.timer = self.create_timer(1.0, self.publish_latest)\n\n        self.latest_message = None\n        self.message_count = 0\n\n    def fast_callback(self, msg):\n        # Receives messages at high rate (e.g., 100 Hz)\n        self.latest_message = msg\n        self.message_count += 1\n\n    def publish_latest(self):\n        # Publishes only latest at 1 Hz\n        if self.latest_message:\n            self.publisher.publish(self.latest_message)\n            self.get_logger().info(\n                f'Published latest (received {self.message_count} messages)'\n            )\n            self.message_count = 0\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"canceling-and-resetting-timers",children:"Canceling and Resetting Timers"}),"\n",(0,i.jsx)(n.h3,{id:"canceling-a-timer",children:"Canceling a Timer"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class CancelableTimerNode(Node):\n    def __init__(self):\n        super().__init__('cancelable_timer_node')\n\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        self.counter = 0\n\n    def timer_callback(self):\n        self.counter += 1\n        self.get_logger().info(f'Count: {self.counter}')\n\n        # Stop after 5 callbacks\n        if self.counter >= 5:\n            self.timer.cancel()\n            self.get_logger().info('Timer canceled')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"creating-one-shot-timers",children:"Creating One-Shot Timers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class OneShotTimerNode(Node):\n    def __init__(self):\n        super().__init__('one_shot_timer_node')\n\n        # Start a timer\n        self.start_one_shot_timer()\n\n    def start_one_shot_timer(self):\n        # Create timer\n        self.timer = self.create_timer(5.0, self.one_shot_callback)\n\n    def one_shot_callback(self):\n        self.get_logger().info('One-shot timer fired!')\n\n        # Cancel immediately to prevent repeat\n        self.timer.cancel()\n\n        # Optionally, start another one-shot\n        # self.start_one_shot_timer()\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-in-callbacks",children:"Error Handling in Callbacks"}),"\n",(0,i.jsx)(n.h3,{id:"try-except-pattern",children:"Try-Except Pattern"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class SafeCallbackNode(Node):\n    def __init__(self):\n        super().__init__('safe_callback_node')\n        self.timer = self.create_timer(1.0, self.safe_callback)\n\n    def safe_callback(self):\n        try:\n            # Risky operation\n            result = self.risky_computation()\n            self.get_logger().info(f'Result: {result}')\n\n        except ZeroDivisionError:\n            self.get_logger().error('Division by zero!')\n\n        except Exception as e:\n            self.get_logger().error(f'Unexpected error: {str(e)}')\n\n    def risky_computation(self):\n        # Might raise exceptions\n        return 10 / 0  # Will raise ZeroDivisionError\n"})}),"\n",(0,i.jsx)(n.h3,{id:"defensive-programming",children:"Defensive Programming"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class RobustNode(Node):\n    def __init__(self):\n        super().__init__('robust_node')\n        self.subscription = self.create_subscription(\n            LaserScan, 'scan', self.scan_callback, 10\n        )\n\n    def scan_callback(self, msg):\n        # Check data validity before processing\n        if not msg.ranges:\n            self.get_logger().warn('Empty scan received')\n            return\n\n        if len(msg.ranges) < 10:\n            self.get_logger().warn('Insufficient scan data')\n            return\n\n        # Safe to process\n        min_range = min(msg.ranges)\n        self.get_logger().info(f'Min range: {min_range:.2f}m')\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-keep-callbacks-short-and-fast",children:"1. Keep Callbacks Short and Fast"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Good: Quick callback\ndef timer_callback(self):\n    msg = String()\n    msg.data = f'Count: {self.counter}'\n    self.publisher.publish(msg)\n    self.counter += 1\n\n# Avoid: Blocking callback\ndef bad_callback(self):\n    time.sleep(5.0)  # Blocks entire event loop!\n    # Other callbacks can't run\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-use-timers-for-periodic-tasks",children:"2. Use Timers for Periodic Tasks"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Good: Timer for periodic publishing\nself.timer = self.create_timer(0.1, self.publish_callback)\n\n# Avoid: Loop in subscription callback\ndef bad_subscription_callback(self, msg):\n    while True:  # Never do this!\n        # Process and publish\n        time.sleep(0.1)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-store-latest-data-process-on-schedule",children:"3. Store Latest Data, Process on Schedule"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Good pattern\ndef __init__(self):\n    self.subscription = self.create_subscription(...)\n    self.timer = self.create_timer(0.1, self.process_callback)\n    self.latest_data = None\n\ndef subscription_callback(self, msg):\n    self.latest_data = msg  # Just store\n\ndef process_callback(self):\n    if self.latest_data:\n        self.process(self.latest_data)  # Process on timer\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-log-at-appropriate-levels",children:"4. Log at Appropriate Levels"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# DEBUG: Verbose details\nself.get_logger().debug('Entering callback')\n\n# INFO: Normal operation\nself.get_logger().info('Message received')\n\n# WARN: Unexpected but handled\nself.get_logger().warn('Data out of range, clamping')\n\n# ERROR: Error occurred\nself.get_logger().error('Failed to process data')\n\n# FATAL: Critical failure\nself.get_logger().fatal('Hardware failure detected')\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-multi-rate-publishing",children:"Exercise 1: Multi-Rate Publishing"}),"\n",(0,i.jsx)(n.p,{children:"Create a node with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast timer (10 Hz) that increments a counter"}),"\n",(0,i.jsx)(n.li,{children:"Medium timer (1 Hz) that publishes the counter value"}),"\n",(0,i.jsx)(n.li,{children:"Slow timer (0.2 Hz) that resets the counter"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class MultiRateNode(Node):\n    def __init__(self):\n        super().__init__('multi_rate_node')\n\n        # TODO: Create publisher for counter\n        # TODO: Create three timers with different rates\n        # TODO: Initialize counter\n\n    def fast_callback(self):\n        # TODO: Increment counter\n        pass\n\n    def medium_callback(self):\n        # TODO: Publish counter value\n        pass\n\n    def slow_callback(self):\n        # TODO: Reset counter\n        pass\n"})}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-sensor-fusion",children:"Exercise 2: Sensor Fusion"}),"\n",(0,i.jsx)(n.p,{children:"Create a node that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Subscribes to two sensor topics (simulate with String messages)"}),"\n",(0,i.jsx)(n.li,{children:"Stores the latest reading from each sensor"}),"\n",(0,i.jsx)(n.li,{children:"On a timer (5 Hz), combines both readings and publishes result"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"You've learned to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create and manage timers"}),"\n",(0,i.jsx)(n.li,{children:"Handle multiple callbacks efficiently"}),"\n",(0,i.jsx)(n.li,{children:"Use callback groups for parallel execution"}),"\n",(0,i.jsx)(n.li,{children:"Measure and optimize callback timing"}),"\n",(0,i.jsx)(n.li,{children:"Implement error handling in callbacks"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Takeaways:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Keep callbacks fast to avoid blocking"}),"\n",(0,i.jsx)(n.li,{children:"Use timers for periodic operations"}),"\n",(0,i.jsx)(n.li,{children:"Store latest data, process on schedule"}),"\n",(0,i.jsx)(n.li,{children:"Use callback groups for parallelism"}),"\n",(0,i.jsx)(n.li,{children:"Always handle exceptions"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch2-python-rclpy/parameters",children:"Parameters"})," - Make nodes configurable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch3-urdf/urdf-syntax",children:"URDF Syntax"})," - Model robots"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-1-ros2/ch4-packages/debugging",children:"Debugging"})," - Debug timing issues"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros2.org/latest/api/rclpy/api/timers.html",children:"rclpy Timer API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/How-To-Guides/Using-callback-groups.html",children:"Callback Groups Tutorial"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Executors.html",children:"Executors and Callback Groups"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>r});var l=s(6540);const i={},a=l.createContext(i);function t(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);