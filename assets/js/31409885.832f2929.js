"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[8617],{4305:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-simulation/ch5-gazebo/spawning-robots","title":"Spawning Robots in Gazebo","description":"Now that you understand the architecture of a Gazebo world, it\'s time for the exciting part: adding a robot to it! This process is called \\"spawning.\\" You can spawn a robot from a URDF or SDF file using several methods, including ROS 2 launch files, command-line tools, and services.","source":"@site/docs/module-2-simulation/ch5-gazebo/spawning-robots.md","sourceDirName":"module-2-simulation/ch5-gazebo","slug":"/module-2-simulation/ch5-gazebo/spawning-robots","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/spawning-robots","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-simulation/ch5-gazebo/spawning-robots.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Gazebo Architecture","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/gazebo-architecture"},"next":{"title":"Tuning Physics Parameters in Gazebo","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch5-gazebo/physics-parameters"}}');var i=s(4848),r=s(8453);const t={},a="Spawning Robots in Gazebo",l={},c=[{value:"From URDF to SDF: A Necessary Conversion",id:"from-urdf-to-sdf-a-necessary-conversion",level:2},{value:"Method 1: Spawning with a ROS 2 Launch File (Recommended)",id:"method-1-spawning-with-a-ros-2-launch-file-recommended",level:2},{value:"Example: <code>humanoid_spawn_launch.py</code>",id:"example-humanoid_spawn_launchpy",level:3},{value:"Method 2: Spawning from the Command Line",id:"method-2-spawning-from-the-command-line",level:2},{value:"Method 3: Spawning from a Python Script",id:"method-3-spawning-from-a-python-script",level:2},{value:"Example: <code>spawn_script.py</code>",id:"example-spawn_scriptpy",level:3},{value:"Troubleshooting Common Spawning Issues",id:"troubleshooting-common-spawning-issues",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"spawning-robots-in-gazebo",children:"Spawning Robots in Gazebo"})}),"\n",(0,i.jsx)(n.p,{children:'Now that you understand the architecture of a Gazebo world, it\'s time for the exciting part: adding a robot to it! This process is called "spawning." You can spawn a robot from a URDF or SDF file using several methods, including ROS 2 launch files, command-line tools, and services.'}),"\n",(0,i.jsx)(n.h2,{id:"from-urdf-to-sdf-a-necessary-conversion",children:"From URDF to SDF: A Necessary Conversion"}),"\n",(0,i.jsxs)(n.p,{children:["A key point to understand is that ",(0,i.jsx)(n.strong,{children:"Gazebo natively uses the Simulation Description Format (SDF)"}),". While ROS heavily relies on the Unified Robot Description Format (URDF) for robot modeling, Gazebo's physics engine requires SDF for full functionality."]}),"\n",(0,i.jsxs)(n.p,{children:["When you load a URDF file into Gazebo, it's ",(0,i.jsx)(n.strong,{children:"automatically converted to SDF"})," behind the scenes. However, this conversion has limitations:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"URDFs cannot specify many of the rich simulation parameters that SDFs can (e.g., friction coefficients, damping, sensor plugins)."}),"\n",(0,i.jsxs)(n.li,{children:["To add Gazebo-specific features, you must add special ",(0,i.jsx)(n.code,{children:"<gazebo>"})," tags to your URDF file, which are then parsed during the conversion."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For this reason, you will often see both URDF and SDF files used in ROS 2 projects."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"URDF"}),": Great for general robot structure, kinematics, and visualization in RViz."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SDF"}),": Best for high-fidelity simulation in Gazebo."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"method-1-spawning-with-a-ros-2-launch-file-recommended",children:"Method 1: Spawning with a ROS 2 Launch File (Recommended)"}),"\n",(0,i.jsxs)(n.p,{children:["The most common and robust method for spawning a robot is using a ROS 2 launch file. This approach automates the entire process, making it repeatable and easy to manage. The key is the ",(0,i.jsx)(n.code,{children:"spawn_entity.py"})," script provided by the ",(0,i.jsx)(n.code,{children:"ros_gz_sim"})," package."]}),"\n",(0,i.jsx)(n.p,{children:"Here\u2019s a typical workflow within a launch file:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Get the path to your robot's URDF/SDF file."})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Launch the Gazebo simulation"})," with your desired world file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Launch a ",(0,i.jsx)(n.code,{children:"robot_state_publisher"})," node."]})," This node reads your URDF, finds the joint states, and publishes the robot's ",(0,i.jsx)(n.code,{children:"tf2"})," transforms. This is essential for visualizing the robot in RViz and for many other ROS 2 nodes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Launch the ",(0,i.jsx)(n.code,{children:"spawn_entity.py"})," node."]})," This node takes your robot description file and calls the Gazebo service ",(0,i.jsx)(n.code,{children:"/spawn_entity"})," to add it to the simulation."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"example-humanoid_spawn_launchpy",children:["Example: ",(0,i.jsx)(n.code,{children:"humanoid_spawn_launch.py"})]}),"\n",(0,i.jsx)(n.p,{children:"Let's break down a launch file that spawns a humanoid robot from a URDF file."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import ExecuteProcess\nfrom launch_ros.actions import Node\nfrom launch.substitutions import LaunchConfiguration\n\ndef generate_launch_description():\n    # 1. Get the path to the URDF file\n    urdf_file_name = 'simple_humanoid.urdf'\n    urdf_path = os.path.join(\n        get_package_share_directory('your_robot_package'),\n        'urdf',\n        urdf_file_name)\n\n    # 2. Read the URDF file content\n    with open(urdf_path, 'r') as infp:\n        robot_desc = infp.read()\n\n    # 3. Launch Gazebo\n    # We use 'gz sim' which is the new command for Gazebo Fortress/Garden\n    gazebo = ExecuteProcess(\n        cmd=['gz', 'sim', '-r', 'empty.world'],\n        output='screen'\n    )\n\n    # 4. Robot State Publisher\n    # This node publishes the robot's state to TF2\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='both',\n        parameters=[{'robot_description': robot_desc}]\n    )\n\n    # 5. Spawn Entity Node\n    # This node spawns the robot model in Gazebo\n    spawn_entity = Node(\n        package='ros_gz_sim',\n        executable='create',\n        output='screen',\n        arguments=[\n            '-string', robot_desc,\n            '-name', 'humanoid',\n            '-allow_renaming', 'true'\n        ]\n    )\n\n    return LaunchDescription([\n        gazebo,\n        robot_state_publisher,\n        spawn_entity\n    ])\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"To run this launch file:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 launch your_robot_package humanoid_spawn_launch.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"method-2-spawning-from-the-command-line",children:"Method 2: Spawning from the Command Line"}),"\n",(0,i.jsxs)(n.p,{children:["You can also spawn a robot manually using the ",(0,i.jsx)(n.code,{children:"ros2 service call"})," command. This is useful for debugging or for adding objects to an already-running simulation."]}),"\n",(0,i.jsxs)(n.p,{children:["The service we need to call is ",(0,i.jsx)(n.code,{children:"/spawn_entity"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Start Gazebo:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"gz sim -r empty.world\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Get your robot's XML content:"}),"\nYou can either pass the file path directly or read the file content into a string."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Call the service:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Make sure your URDF/SDF file exists at this path\nros2 service call /spawn_entity ros_gz_interfaces/srv/SpawnEntity \"{\n    name: 'my_robot',\n    xml: '$(cat /path/to/your/robot.urdf)',\n    robot_namespace: 'my_robot',\n    initial_pose: {\n        position: {x: 0, y: 0, z: 1.0},\n        orientation: {x: 0, y: 0, z: 0, w: 1}\n    }\n}\"\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Key Parameters for the ",(0,i.jsx)(n.code,{children:"SpawnEntity"})," service:"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name"}),": A unique name for your robot in the simulation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"xml"}),": The full XML content of your URDF or SDF file as a string."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"robot_namespace"}),": The ROS 2 namespace for the robot's topics and services."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"initial_pose"}),": Where to spawn the robot in the world."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"method-3-spawning-from-a-python-script",children:"Method 3: Spawning from a Python Script"}),"\n",(0,i.jsx)(n.p,{children:"You can achieve the same result as the command-line method from within a Python script by creating a ROS 2 service client. This gives you programmatic control over when and how entities are spawned."}),"\n",(0,i.jsxs)(n.h3,{id:"example-spawn_scriptpy",children:["Example: ",(0,i.jsx)(n.code,{children:"spawn_script.py"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom ros_gz_interfaces.srv import SpawnEntity\n\nclass Spawner(Node):\n    def __init__(self):\n        super().__init__('robot_spawner')\n        self.cli = self.create_client(SpawnEntity, '/spawn_entity')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service /spawn_entity not available, waiting...')\n        \n        # Path to your robot description file\n        urdf_path = '/path/to/your/robot.urdf'\n        with open(urdf_path, 'r') as f:\n            self.robot_xml = f.read()\n\n    def send_request(self):\n        req = SpawnEntity.Request()\n        req.name = 'script_spawned_robot'\n        req.xml = self.robot_xml\n        req.initial_pose.position.z = 1.5 # Spawn slightly higher\n\n        self.future = self.cli.call_async(req)\n        rclpy.spin_until_future_complete(self, self.future)\n        \n        if self.future.result() is not None:\n            self.get_logger().info(f'Spawn successful: {self.future.result().success}')\n        else:\n            self.get_logger().error('Service call failed')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    spawner = Spawner()\n    spawner.send_request()\n    spawner.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting-common-spawning-issues",children:"Troubleshooting Common Spawning Issues"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:'"Service /spawn_entity not available"'}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Gazebo isn't running, or the ",(0,i.jsx)(n.code,{children:"ros_gz_bridge"})," hasn't been started correctly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Ensure ",(0,i.jsx)(n.code,{children:"gz sim"})," is running and that the ",(0,i.jsx)(n.code,{children:"ros_gz_sim"})," package is installed and sourced."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Robot falls through the ground plane"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Missing ",(0,i.jsx)(n.code,{children:"<collision>"})," tags in your URDF/SDF, or the collision geometry is incorrect."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Verify that every ",(0,i.jsx)(n.code,{children:"<link>"})," has a corresponding ",(0,i.jsx)(n.code,{children:"<collision>"})," tag. Check that the collision shapes are valid."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:'Robot appears "exploded" or parts are in the wrong place'}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Incorrect joint origins or axes in your URDF."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Use ",(0,i.jsx)(n.code,{children:"rviz2"})," and a ",(0,i.jsx)(n.code,{children:"joint_state_publisher"})," to debug your URDF separately from Gazebo. Ensure your joint kinematics are correct."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:'"Could not find package..."'}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cause"}),": Your ROS 2 workspace isn't sourced, or the package containing your robot description isn't installed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Solution"}),": Run ",(0,i.jsx)(n.code,{children:"source install/setup.bash"})," in your workspace and make sure you've built your robot's package with ",(0,i.jsx)(n.code,{children:"colcon build"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"With these methods, you have a complete toolkit for getting your robots into the simulation. The launch file method is preferred for its robustness, but the others are excellent for debugging and dynamic control."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var o=s(6540);const i={},r=o.createContext(i);function t(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);