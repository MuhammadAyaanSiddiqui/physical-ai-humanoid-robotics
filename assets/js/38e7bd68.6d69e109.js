"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[150],{5552:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-4-vla/ch12-llm-planning/action-generation","title":"Action Generation and ROS 2 Conversion","description":"Learning Objectives","source":"@site/docs/module-4-vla/ch12-llm-planning/action-generation.md","sourceDirName":"module-4-vla/ch12-llm-planning","slug":"/module-4-vla/ch12-llm-planning/action-generation","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch12-llm-planning/action-generation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-vla/ch12-llm-planning/action-generation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Prompt Engineering for Robotics Tasks","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch12-llm-planning/prompt-engineering"},"next":{"title":"Error Handling and Fault Recovery","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch12-llm-planning/error-handling"}}');var a=t(4848),o=t(8453);const c={},r="Action Generation and ROS 2 Conversion",s={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Part 1: Action Schema Definition",id:"part-1-action-schema-definition",level:2},{value:"Step 1: Define Action Schema",id:"step-1-define-action-schema",level:3},{value:"Step 2: JSON to Action Converter",id:"step-2-json-to-action-converter",level:3},{value:"Part 2: Action Validation",id:"part-2-action-validation",level:2},{value:"Step 1: Validation Rules",id:"step-1-validation-rules",level:3},{value:"Part 3: ROS 2 Action Integration",id:"part-3-ros-2-action-integration",level:2},{value:"Step 1: Define ROS 2 Action Messages",id:"step-1-define-ros-2-action-messages",level:3},{value:"Step 2: Action Executor Node",id:"step-2-action-executor-node",level:3},{value:"Step 3: Complete Pipeline Test",id:"step-3-complete-pipeline-test",level:3},{value:"Part 4: Error Recovery",id:"part-4-error-recovery",level:2},{value:"Step 1: Action Retry Logic",id:"step-1-action-retry-logic",level:3},{value:"Step 2: Replanning on Failure",id:"step-2-replanning-on-failure",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Exercise 1: Action Cost Estimator",id:"exercise-1-action-cost-estimator",level:3},{value:"Exercise 2: Parallel Action Execution",id:"exercise-2-parallel-action-execution",level:3},{value:"Summary",id:"summary",level:2},{value:"Additional Resources",id:"additional-resources",level:2},{value:"ROS 2 Actions",id:"ros-2-actions",level:3},{value:"Validation Libraries",id:"validation-libraries",level:3},{value:"Next Lesson",id:"next-lesson",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"action-generation-and-ros-2-conversion",children:"Action Generation and ROS 2 Conversion"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Convert LLM JSON outputs to ROS 2 action goals"}),"\n",(0,a.jsx)(e.li,{children:"Validate and sanitize generated action sequences"}),"\n",(0,a.jsx)(e.li,{children:"Implement action execution with feedback monitoring"}),"\n",(0,a.jsx)(e.li,{children:"Handle invalid or infeasible actions gracefully"}),"\n",(0,a.jsx)(e.li,{children:"Build a complete LLM \u2192 ROS 2 action pipeline"}),"\n",(0,a.jsx)(e.li,{children:"Optimize execution for real-time robotics"}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Required Knowledge"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Completion of ",(0,a.jsx)(e.a,{href:"/physical-ai-humanoid-robotics/docs/module-4-vla/ch12-llm-planning/prompt-engineering",children:"Lesson 2: Prompt Engineering"})]}),"\n",(0,a.jsx)(e.li,{children:"ROS 2 actions (action servers/clients)"}),"\n",(0,a.jsx)(e.li,{children:"JSON parsing in Python"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Required Software"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"ROS 2 Humble"}),"\n",(0,a.jsx)(e.li,{children:"Python 3.10+"}),"\n",(0,a.jsx)(e.li,{children:"OpenAI or Anthropic API access"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Estimated Time"}),": 3-4 hours"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"LLMs generate high-level action plans in JSON format:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",children:'{\n  "plan": [\n    {"action": "navigate", "location": "kitchen"},\n    {"action": "pick", "object": "cup", "color": "red"}\n  ]\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"These must be converted to ROS 2 action goals and executed sequentially with error handling."}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Pipeline Overview"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"Voice Command \u2192 LLM \u2192 JSON Plan \u2192 Validation \u2192 ROS 2 Actions \u2192 Robot Execution\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"part-1-action-schema-definition",children:"Part 1: Action Schema Definition"}),"\n",(0,a.jsx)(e.h3,{id:"step-1-define-action-schema",children:"Step 1: Define Action Schema"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nfrom dataclasses import dataclass\nfrom typing import Optional, List\nfrom enum import Enum\n\nclass ActionType(Enum):\n    NAVIGATE = "navigate"\n    PICK = "pick"\n    PLACE = "place"\n    SCAN = "scan"\n    WAIT = "wait"\n\n@dataclass\nclass NavigateAction:\n    action_type: ActionType = ActionType.NAVIGATE\n    location: Optional[str] = None\n    x: Optional[float] = None\n    y: Optional[float] = None\n    theta: Optional[float] = None\n\n@dataclass\nclass PickAction:\n    action_type: ActionType = ActionType.PICK\n    object_name: str = ""\n    color: Optional[str] = None\n    size: Optional[str] = None\n\n@dataclass\nclass PlaceAction:\n    action_type: ActionType = ActionType.PLACE\n    object_name: str = ""\n    location: str = ""\n    x: Optional[float] = None\n    y: Optional[float] = None\n\n@dataclass\nclass ScanAction:\n    action_type: ActionType = ActionType.SCAN\n    target: Optional[str] = None\n\n@dataclass\nclass WaitAction:\n    action_type: ActionType = ActionType.WAIT\n    duration: float = 0.0\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"step-2-json-to-action-converter",children:"Step 2: JSON to Action Converter"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport json\nfrom typing import List, Union\n\nActionUnion = Union[NavigateAction, PickAction, PlaceAction, ScanAction, WaitAction]\n\nclass ActionConverter:\n    \"\"\"Convert LLM JSON output to typed action objects\"\"\"\n\n    def parse_plan(self, llm_output: str) -> List[ActionUnion]:\n        \"\"\"Parse LLM JSON string into action objects\"\"\"\n        try:\n            data = json.loads(llm_output)\n            plan = data.get('plan', [])\n\n            actions = []\n            for action_dict in plan:\n                action = self.parse_action(action_dict)\n                if action:\n                    actions.append(action)\n\n            return actions\n\n        except json.JSONDecodeError as e:\n            raise ValueError(f\"Invalid JSON from LLM: {e}\")\n\n    def parse_action(self, action_dict: dict) -> Optional[ActionUnion]:\n        \"\"\"Parse single action dictionary\"\"\"\n        action_type = action_dict.get('action', '').lower()\n\n        if action_type == 'navigate':\n            return NavigateAction(\n                location=action_dict.get('location'),\n                x=action_dict.get('x'),\n                y=action_dict.get('y'),\n                theta=action_dict.get('theta')\n            )\n\n        elif action_type == 'pick':\n            return PickAction(\n                object_name=action_dict.get('object', ''),\n                color=action_dict.get('color'),\n                size=action_dict.get('size')\n            )\n\n        elif action_type == 'place':\n            return PlaceAction(\n                object_name=action_dict.get('object', ''),\n                location=action_dict.get('location', ''),\n                x=action_dict.get('x'),\n                y=action_dict.get('y')\n            )\n\n        elif action_type == 'scan':\n            return ScanAction(\n                target=action_dict.get('target')\n            )\n\n        elif action_type == 'wait':\n            return WaitAction(\n                duration=action_dict.get('duration', 0.0)\n            )\n\n        else:\n            print(f\"Unknown action type: {action_type}\")\n            return None\n\n# Usage\nconverter = ActionConverter()\n\nllm_json = '''\n{\n  \"plan\": [\n    {\"action\": \"navigate\", \"location\": \"kitchen\"},\n    {\"action\": \"pick\", \"object\": \"cup\", \"color\": \"red\"}\n  ]\n}\n'''\n\nactions = converter.parse_plan(llm_json)\nfor action in actions:\n    print(f\"{action.action_type.value}: {action}\")\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"part-2-action-validation",children:"Part 2: Action Validation"}),"\n",(0,a.jsx)(e.h3,{id:"step-1-validation-rules",children:"Step 1: Validation Rules"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nfrom typing import List, Tuple\n\nclass ActionValidator:\n    """Validate action sequences for feasibility and safety"""\n\n    def __init__(self):\n        self.max_move_distance = 10.0  # meters\n        self.max_object_weight = 5.0   # kg\n        self.known_locations = {\'kitchen\', \'bedroom\', \'living_room\'}\n        self.object_weights = {\n            \'cup\': 0.3,\n            \'plate\': 0.5,\n            \'book\': 1.0,\n            \'box\': 2.0,\n            \'engine\': 50.0  # Too heavy!\n        }\n\n    def validate_plan(self, actions: List[ActionUnion]) -> Tuple[bool, List[str]]:\n        """\n        Validate entire action plan\n\n        Returns:\n            (is_valid, list_of_errors)\n        """\n        errors = []\n\n        for i, action in enumerate(actions):\n            action_errors = self.validate_action(action, i, actions)\n            errors.extend(action_errors)\n\n        return (len(errors) == 0, errors)\n\n    def validate_action(self, action: ActionUnion, index: int, all_actions: List) -> List[str]:\n        """Validate single action"""\n        errors = []\n\n        if isinstance(action, NavigateAction):\n            # Check location is known\n            if action.location and action.location not in self.known_locations:\n                errors.append(f"Action {index}: Unknown location \'{action.location}\'")\n\n            # Check distance if using x/y coordinates\n            if action.x is not None and action.y is not None:\n                distance = (action.x**2 + action.y**2) ** 0.5\n                if distance > self.max_move_distance:\n                    errors.append(f"Action {index}: Movement distance {distance:.1f}m exceeds limit of {self.max_move_distance}m")\n\n        elif isinstance(action, PickAction):\n            # Check object weight\n            weight = self.object_weights.get(action.object_name.lower(), 0.0)\n            if weight > self.max_object_weight:\n                errors.append(f"Action {index}: Object \'{action.object_name}\' ({weight}kg) exceeds weight limit ({self.max_object_weight}kg)")\n\n            # Check previous actions: must scan before pick\n            if not self._has_previous_scan(action.object_name, index, all_actions):\n                errors.append(f"Action {index}: Must scan for \'{action.object_name}\' before picking")\n\n        elif isinstance(action, PlaceAction):\n            # Check we picked something before placing\n            if not self._has_previous_pick(action.object_name, index, all_actions):\n                errors.append(f"Action {index}: Cannot place \'{action.object_name}\' without picking it first")\n\n        return errors\n\n    def _has_previous_scan(self, object_name: str, current_index: int, actions: List) -> bool:\n        """Check if object was scanned before current action"""\n        for i in range(current_index):\n            action = actions[i]\n            if isinstance(action, ScanAction):\n                if action.target is None or action.target == object_name:\n                    return True\n        return False\n\n    def _has_previous_pick(self, object_name: str, current_index: int, actions: List) -> bool:\n        """Check if object was picked before current action"""\n        for i in range(current_index):\n            action = actions[i]\n            if isinstance(action, PickAction) and action.object_name == object_name:\n                return True\n        return False\n\n# Usage\nvalidator = ActionValidator()\n\n# Valid plan\nvalid_actions = [\n    ScanAction(target="cup"),\n    PickAction(object_name="cup", color="red"),\n    PlaceAction(object_name="cup", location="table")\n]\n\nis_valid, errors = validator.validate_plan(valid_actions)\nprint(f"Valid: {is_valid}")\nif errors:\n    for error in errors:\n        print(f"  \u274c {error}")\n\n# Invalid plan (missing scan)\ninvalid_actions = [\n    PickAction(object_name="cup"),  # No scan!\n]\n\nis_valid, errors = validator.validate_plan(invalid_actions)\nprint(f"\\nValid: {is_valid}")\nfor error in errors:\n    print(f"  \u274c {error}")\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"part-3-ros-2-action-integration",children:"Part 3: ROS 2 Action Integration"}),"\n",(0,a.jsx)(e.h3,{id:"step-1-define-ros-2-action-messages",children:"Step 1: Define ROS 2 Action Messages"}),"\n",(0,a.jsxs)(e.p,{children:["Create ",(0,a.jsx)(e.code,{children:"NavigateToGoal.action"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"# Goal\nstring action_type  # navigate, pick, place, scan\nstring location\nfloat32 x\nfloat32 y\nfloat32 theta\nstring object_name\nstring object_color\n---\n# Result\nbool success\nstring message\n---\n# Feedback\nstring current_status\nfloat32 progress\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"step-2-action-executor-node",children:"Step 2: Action Executor Node"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom my_robot_interfaces.action import NavigateToGoal\nfrom std_msgs.msg import String\nimport json\nimport time\n\nclass ActionExecutor(Node):\n    def __init__(self):\n        super().__init__(\'action_executor\')\n\n        # Subscribers\n        self.plan_sub = self.create_subscription(\n            String,\n            \'llm/action_plan\',\n            self.plan_callback,\n            10\n        )\n\n        # Action clients\n        self.nav_client = ActionClient(self, NavigateToGoal, \'execute_action\')\n\n        # State\n        self.current_plan = []\n        self.current_action_index = 0\n        self.executing = False\n\n        # Initialize validator and converter\n        self.converter = ActionConverter()\n        self.validator = ActionValidator()\n\n        self.get_logger().info(\'Action Executor ready\')\n\n    def plan_callback(self, msg: String):\n        """Receive and execute action plan"""\n        try:\n            # Parse JSON plan\n            actions = self.converter.parse_plan(msg.data)\n\n            # Validate plan\n            is_valid, errors = self.validator.validate_plan(actions)\n\n            if not is_valid:\n                self.get_logger().error(f"Invalid plan: {errors}")\n                return\n\n            # Execute plan\n            self.current_plan = actions\n            self.current_action_index = 0\n            self.executing = True\n\n            self.execute_next_action()\n\n        except Exception as e:\n            self.get_logger().error(f"Plan execution failed: {e}")\n\n    def execute_next_action(self):\n        """Execute next action in plan"""\n        if not self.executing:\n            return\n\n        if self.current_action_index >= len(self.current_plan):\n            self.get_logger().info(\'\u2705 Plan completed successfully!\')\n            self.executing = False\n            return\n\n        action = self.current_plan[self.current_action_index]\n        self.get_logger().info(f\'Executing action {self.current_action_index + 1}/{len(self.current_plan)}: {action.action_type.value}\')\n\n        # Convert to ROS 2 action goal\n        goal = self.action_to_ros_goal(action)\n\n        # Send goal\n        self.nav_client.wait_for_server()\n        send_future = self.nav_client.send_goal_async(\n            goal,\n            feedback_callback=self.feedback_callback\n        )\n        send_future.add_done_callback(self.goal_response_callback)\n\n    def action_to_ros_goal(self, action: ActionUnion) -> NavigateToGoal.Goal:\n        """Convert action object to ROS 2 action goal"""\n        goal = NavigateToGoal.Goal()\n\n        if isinstance(action, NavigateAction):\n            goal.action_type = \'navigate\'\n            goal.location = action.location or \'\'\n            goal.x = action.x or 0.0\n            goal.y = action.y or 0.0\n            goal.theta = action.theta or 0.0\n\n        elif isinstance(action, PickAction):\n            goal.action_type = \'pick\'\n            goal.object_name = action.object_name\n            goal.object_color = action.color or \'\'\n\n        elif isinstance(action, PlaceAction):\n            goal.action_type = \'place\'\n            goal.object_name = action.object_name\n            goal.location = action.location\n\n        elif isinstance(action, ScanAction):\n            goal.action_type = \'scan\'\n            goal.object_name = action.target or \'\'\n\n        return goal\n\n    def goal_response_callback(self, future):\n        """Handle goal acceptance/rejection"""\n        goal_handle = future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().error(\'Goal rejected!\')\n            self.executing = False\n            return\n\n        self.get_logger().info(\'Goal accepted\')\n\n        # Wait for result\n        result_future = goal_handle.get_result_async()\n        result_future.add_done_callback(self.result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        """Handle action feedback"""\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f\'  Progress: {feedback.progress:.0f}% - {feedback.current_status}\')\n\n    def result_callback(self, future):\n        """Handle action result"""\n        result = future.result().result\n\n        if result.success:\n            self.get_logger().info(f\'  \u2705 Action succeeded: {result.message}\')\n\n            # Move to next action\n            self.current_action_index += 1\n            self.execute_next_action()\n        else:\n            self.get_logger().error(f\'  \u274c Action failed: {result.message}\')\n            self.executing = False\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ActionExecutor()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"step-3-complete-pipeline-test",children:"Step 3: Complete Pipeline Test"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Terminal 1"})," (LLM Planning Node):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"python3 llm_planning_node.py\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Terminal 2"})," (Action Executor):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"python3 action_executor.py\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Terminal 3"})," (Mock Action Server for testing):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"python3 mock_action_server.py\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Terminal 4"})," (Send command):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"ros2 service call /llm_plan my_robot_interfaces/srv/LLMPlan \\\n  \"{command: 'Go to the kitchen and pick up the red cup'}\"\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Expected flow"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"[llm_planning_node] Generating plan...\n[llm_planning_node] Published plan with 3 actions\n[action_executor] Validating plan... \u2713\n[action_executor] Executing action 1/3: navigate\n[mock_action_server] Navigating to kitchen...\n[action_executor] Progress: 50% - Moving\n[action_executor] \u2705 Action succeeded\n[action_executor] Executing action 2/3: scan\n[action_executor] Executing action 3/3: pick\n[action_executor] \u2705 Plan completed successfully!\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"part-4-error-recovery",children:"Part 4: Error Recovery"}),"\n",(0,a.jsx)(e.h3,{id:"step-1-action-retry-logic",children:"Step 1: Action Retry Logic"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class RobustActionExecutor(ActionExecutor):\n    """Action executor with retry and recovery"""\n\n    def __init__(self):\n        super().__init__()\n        self.max_retries = 3\n        self.current_retries = 0\n\n    def result_callback(self, future):\n        """Handle result with retry logic"""\n        result = future.result().result\n\n        if result.success:\n            # Success - reset retries and move to next action\n            self.current_retries = 0\n            self.current_action_index += 1\n            self.execute_next_action()\n\n        else:\n            # Failure - retry or skip\n            self.current_retries += 1\n\n            if self.current_retries < self.max_retries:\n                self.get_logger().warn(\n                    f\'Action failed. Retrying ({self.current_retries}/{self.max_retries})...\'\n                )\n                time.sleep(1)  # Wait before retry\n                self.execute_next_action()  # Retry same action\n\n            else:\n                self.get_logger().error(\n                    f\'Action failed after {self.max_retries} retries. Skipping.\'\n                )\n                self.current_retries = 0\n                self.current_action_index += 1\n                self.execute_next_action()  # Skip to next action\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"step-2-replanning-on-failure",children:"Step 2: Replanning on Failure"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'def result_callback_with_replanning(self, future):\n    """Replan if action fails"""\n    result = future.result().result\n\n    if not result.success:\n        self.get_logger().warn(f\'Action failed: {result.message}\')\n\n        # Get current state\n        current_state = self.get_robot_state()\n\n        # Replan remaining tasks\n        remaining_goal = self.get_remaining_goal()\n\n        self.get_logger().info(f\'Replanning to achieve: {remaining_goal}\')\n\n        # Call LLM to generate new plan\n        new_plan = self.replan(remaining_goal, current_state)\n\n        # Execute new plan\n        self.current_plan = new_plan\n        self.current_action_index = 0\n        self.execute_next_action()\n\ndef replan(self, goal: str, state: dict) -> List[ActionUnion]:\n    """Call LLM to generate new plan"""\n    # TODO: Call LLM service with updated state\n    # Return new action list\n    pass\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,a.jsx)(e.h3,{id:"exercise-1-action-cost-estimator",children:"Exercise 1: Action Cost Estimator"}),"\n",(0,a.jsx)(e.p,{children:"Build a system to estimate execution time and cost before running plan:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Estimate time for each action type (navigate: 5s, pick: 3s, etc.)"}),"\n",(0,a.jsx)(e.li,{children:"Calculate total plan duration"}),"\n",(0,a.jsx)(e.li,{children:"Warn if plan exceeds time budget"}),"\n",(0,a.jsx)(e.li,{children:"Display progress bar during execution"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Starter code"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class ActionCostEstimator:\n    def __init__(self):\n        self.action_costs = {\n            ActionType.NAVIGATE: 5.0,  # seconds\n            ActionType.PICK: 3.0,\n            ActionType.PLACE: 2.0,\n            ActionType.SCAN: 2.0\n        }\n\n    def estimate_plan(self, actions: List[ActionUnion]) -> dict:\n        """Estimate plan execution time and cost"""\n        # TODO: Sum action costs\n        # TODO: Add transition overhead\n        # TODO: Calculate battery usage\n        # TODO: Return estimate dict\n        pass\n\n# Usage\nestimator = ActionCostEstimator()\nestimate = estimator.estimate_plan(actions)\nprint(f"Estimated time: {estimate[\'duration\']}s")\nprint(f"Battery: {estimate[\'battery_percent\']}%")\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h3,{id:"exercise-2-parallel-action-execution",children:"Exercise 2: Parallel Action Execution"}),"\n",(0,a.jsx)(e.p,{children:"Implement parallel execution for independent actions:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Requirements"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Identify actions that can run in parallel (scan + navigate to different areas)"}),"\n",(0,a.jsx)(e.li,{children:"Execute parallel actions simultaneously"}),"\n",(0,a.jsx)(e.li,{children:"Wait for all to complete before next sequential action"}),"\n",(0,a.jsx)(e.li,{children:"Handle partial failures"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Hint"}),": Use ",(0,a.jsx)(e.code,{children:"asyncio"})," or ROS 2 executor threads"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"In this lesson, you learned to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"\u2705 Convert LLM JSON outputs to typed action objects"}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Validate action plans for feasibility and safety"}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Implement ROS 2 action execution pipeline"}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Handle action failures with retries and replanning"}),"\n",(0,a.jsx)(e.li,{children:"\u2705 Build complete LLM \u2192 ROS 2 integration"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validation is critical"}),": Check feasibility before execution"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Type safety"}),": Use dataclasses to catch errors early"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Error handling"}),": Always retry and replan on failures"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Feedback loops"}),": Monitor execution progress for debugging"]}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,a.jsx)(e.h3,{id:"ros-2-actions",children:"ROS 2 Actions"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/Writing-an-Action-Server-Client/Py.html",children:"ROS 2 Action Tutorial"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://design.ros2.org/articles/actions.html",children:"Action Design Patterns"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"validation-libraries",children:"Validation Libraries"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"https://pydantic-docs.helpmanual.io/",children:"Pydantic"})," - Data validation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"https://json-schema.org/",children:"JSON Schema"})," - Schema validation"]}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"next-lesson",children:"Next Lesson"}),"\n",(0,a.jsxs)(e.p,{children:["In ",(0,a.jsx)(e.strong,{children:"Lesson 4: Error Handling"}),", you'll learn to:"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Detect and diagnose action failures"}),"\n",(0,a.jsx)(e.li,{children:"Implement intelligent fallback strategies"}),"\n",(0,a.jsx)(e.li,{children:"Handle ambiguous commands with clarification"}),"\n",(0,a.jsx)(e.li,{children:"Build fault-tolerant robot systems"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["Continue to ",(0,a.jsx)(e.a,{href:"/physical-ai-humanoid-robotics/docs/module-4-vla/ch12-llm-planning/error-handling",children:"Error Handling \u2192"})]})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>r});var i=t(6540);const a={},o=i.createContext(a);function c(n){const e=i.useContext(o);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:c(n.components),i.createElement(o.Provider,{value:e},n.children)}}}]);