"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[1143],{2582:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-4-vla/ch13-humanoid-control/forward-inverse-kinematics","title":"Forward and Inverse Kinematics for Humanoid Robots","description":"Learning Objectives","source":"@site/docs/module-4-vla/ch13-humanoid-control/forward-inverse-kinematics.md","sourceDirName":"module-4-vla/ch13-humanoid-control","slug":"/module-4-vla/ch13-humanoid-control/forward-inverse-kinematics","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/forward-inverse-kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-vla/ch13-humanoid-control/forward-inverse-kinematics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling and Fault Recovery","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch12-llm-planning/error-handling"},"next":{"title":"Bipedal Locomotion and Walking Gaits","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/bipedal-locomotion"}}');var r=i(4848),s=i(8453);const o={},a="Forward and Inverse Kinematics for Humanoid Robots",l={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Part 1: Forward Kinematics",id:"part-1-forward-kinematics",level:2},{value:"Step 1: Denavit-Hartenberg (DH) Parameters",id:"step-1-denavit-hartenberg-dh-parameters",level:3},{value:"Step 2: FK Implementation in Python",id:"step-2-fk-implementation-in-python",level:3},{value:"Part 2: Inverse Kinematics with KDL",id:"part-2-inverse-kinematics-with-kdl",level:2},{value:"Step 1: Install and Setup KDL",id:"step-1-install-and-setup-kdl",level:3},{value:"Step 2: Define Robot Chain in KDL",id:"step-2-define-robot-chain-in-kdl",level:3},{value:"Step 3: Solve IK with KDL",id:"step-3-solve-ik-with-kdl",level:3},{value:"Part 3: Advanced IK with TRAC-IK",id:"part-3-advanced-ik-with-trac-ik",level:2},{value:"Step 1: Install TRAC-IK",id:"step-1-install-trac-ik",level:3},{value:"Step 2: Use TRAC-IK in Python",id:"step-2-use-trac-ik-in-python",level:3},{value:"Part 4: MoveIt Integration",id:"part-4-moveit-integration",level:2},{value:"Step 1: Create MoveIt Config",id:"step-1-create-moveit-config",level:3},{value:"Step 2: Use MoveIt for IK in Python",id:"step-2-use-moveit-for-ik-in-python",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Lesson",id:"next-lesson",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"forward-and-inverse-kinematics-for-humanoid-robots",children:"Forward and Inverse Kinematics for Humanoid Robots"})}),"\n",(0,r.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Understand forward and inverse kinematics (FK/IK) for robotic arms"}),"\n",(0,r.jsx)(e.li,{children:"Implement FK using Denavit-Hartenberg (DH) parameters"}),"\n",(0,r.jsx)(e.li,{children:"Use KDL (Kinematics and Dynamics Library) for IK solving"}),"\n",(0,r.jsx)(e.li,{children:"Optimize IK solutions with TRAC-IK for humanoid robots"}),"\n",(0,r.jsx)(e.li,{children:"Integrate kinematics solvers with ROS 2 MoveIt"}),"\n",(0,r.jsx)(e.li,{children:"Handle singularities and joint limits"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Required Knowledge"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Linear algebra (transformation matrices, rotations)"}),"\n",(0,r.jsx)(e.li,{children:"Python and C++ basics"}),"\n",(0,r.jsx)(e.li,{children:"ROS 2 fundamentals"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Required Software"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"ROS 2 Humble"}),"\n",(0,r.jsx)(e.li,{children:"Python 3.10+"}),"\n",(0,r.jsxs)(e.li,{children:["KDL library (",(0,r.jsx)(e.code,{children:"sudo apt install ros-humble-orocos-kdl"}),")"]}),"\n",(0,r.jsxs)(e.li,{children:["TRAC-IK (",(0,r.jsx)(e.code,{children:"sudo apt install ros-humble-trac-ik"}),")"]}),"\n",(0,r.jsx)(e.li,{children:"MoveIt 2"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Estimated Time"}),": 4-5 hours"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Forward Kinematics (FK)"}),": Given joint angles \u2192 Calculate end-effector pose\n",(0,r.jsx)(e.strong,{children:"Inverse Kinematics (IK)"}),": Given desired end-effector pose \u2192 Calculate joint angles"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"FK"}),": Arm joints at [30\xb0, 45\xb0, 60\xb0] \u2192 Hand position (x=0.5m, y=0.3m, z=0.8m)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"IK"}),": Want hand at (x=0.5m, y=0.3m, z=0.8m) \u2192 Need joints at [30\xb0, 45\xb0, 60\xb0]"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Why IK is Hard"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"No unique solution"}),": Multiple joint configurations can reach same pose"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Singularities"}),": Some poses are unreachable"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Joint limits"}),": Physical constraints on robot movement"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Computational complexity"}),": Solving nonlinear equations"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"part-1-forward-kinematics",children:"Part 1: Forward Kinematics"}),"\n",(0,r.jsx)(e.h3,{id:"step-1-denavit-hartenberg-dh-parameters",children:"Step 1: Denavit-Hartenberg (DH) Parameters"}),"\n",(0,r.jsx)(e.p,{children:"DH parameters define robot kinematics with 4 values per joint:"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Parameter"}),(0,r.jsx)(e.th,{children:"Symbol"}),(0,r.jsx)(e.th,{children:"Description"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Link length"}),(0,r.jsx)(e.td,{children:"a"}),(0,r.jsx)(e.td,{children:"Distance along X-axis"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Link twist"}),(0,r.jsx)(e.td,{children:"\u03b1 (alpha)"}),(0,r.jsx)(e.td,{children:"Rotation around X-axis"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Link offset"}),(0,r.jsx)(e.td,{children:"d"}),(0,r.jsx)(e.td,{children:"Distance along Z-axis"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Joint angle"}),(0,r.jsx)(e.td,{children:"\u03b8 (theta)"}),(0,r.jsx)(e.td,{children:"Rotation around Z-axis"})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example: 3-DOF planar arm"}),":"]}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Joint"}),(0,r.jsx)(e.th,{children:"a (m)"}),(0,r.jsx)(e.th,{children:"\u03b1 (rad)"}),(0,r.jsx)(e.th,{children:"d (m)"}),(0,r.jsx)(e.th,{children:"\u03b8 (rad)"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"1"}),(0,r.jsx)(e.td,{children:"0.5"}),(0,r.jsx)(e.td,{children:"0"}),(0,r.jsx)(e.td,{children:"0"}),(0,r.jsx)(e.td,{children:"\u03b8\u2081"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"2"}),(0,r.jsx)(e.td,{children:"0.3"}),(0,r.jsx)(e.td,{children:"0"}),(0,r.jsx)(e.td,{children:"0"}),(0,r.jsx)(e.td,{children:"\u03b8\u2082"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"3"}),(0,r.jsx)(e.td,{children:"0.2"}),(0,r.jsx)(e.td,{children:"0"}),(0,r.jsx)(e.td,{children:"0"}),(0,r.jsx)(e.td,{children:"\u03b8\u2083"})]})]})]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"step-2-fk-implementation-in-python",children:"Step 2: FK Implementation in Python"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport numpy as np\n\ndef dh_transform(a, alpha, d, theta):\n    """\n    Compute DH transformation matrix\n\n    Args:\n        a: Link length (m)\n        alpha: Link twist (rad)\n        d: Link offset (m)\n        theta: Joint angle (rad)\n\n    Returns:\n        4x4 transformation matrix\n    """\n    ct = np.cos(theta)\n    st = np.sin(theta)\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n\n    T = np.array([\n        [ct,    -st*ca,  st*sa,   a*ct],\n        [st,     ct*ca, -ct*sa,   a*st],\n        [0,      sa,     ca,      d   ],\n        [0,      0,      0,       1   ]\n    ])\n\n    return T\n\ndef forward_kinematics(dh_params, joint_angles):\n    """\n    Compute FK for robot arm\n\n    Args:\n        dh_params: List of (a, alpha, d) for each joint\n        joint_angles: List of theta values (rad)\n\n    Returns:\n        4x4 end-effector pose matrix\n    """\n    T = np.eye(4)  # Start with identity\n\n    for (a, alpha, d), theta in zip(dh_params, joint_angles):\n        T_i = dh_transform(a, alpha, d, theta)\n        T = T @ T_i  # Chain transformations\n\n    return T\n\n# Example: 3-DOF planar arm\ndh_params = [\n    (0.5, 0, 0),  # Joint 1\n    (0.3, 0, 0),  # Joint 2\n    (0.2, 0, 0)   # Joint 3\n]\n\njoint_angles = [np.pi/6, np.pi/4, np.pi/3]  # 30\xb0, 45\xb0, 60\xb0\n\nT_end = forward_kinematics(dh_params, joint_angles)\n\n# Extract position\nx, y, z = T_end[0:3, 3]\nprint(f"End-effector position: x={x:.3f}, y={y:.3f}, z={z:.3f}")\n\n# Extract orientation (roll-pitch-yaw)\ndef rotation_to_euler(R):\n    """Convert rotation matrix to Euler angles (XYZ convention)"""\n    roll = np.arctan2(R[2, 1], R[2, 2])\n    pitch = np.arctan2(-R[2, 0], np.sqrt(R[2, 1]**2 + R[2, 2]**2))\n    yaw = np.arctan2(R[1, 0], R[0, 0])\n    return roll, pitch, yaw\n\nroll, pitch, yaw = rotation_to_euler(T_end[0:3, 0:3])\nprint(f"Orientation: roll={np.degrees(roll):.1f}\xb0, pitch={np.degrees(pitch):.1f}\xb0, yaw={np.degrees(yaw):.1f}\xb0")\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"part-2-inverse-kinematics-with-kdl",children:"Part 2: Inverse Kinematics with KDL"}),"\n",(0,r.jsx)(e.h3,{id:"step-1-install-and-setup-kdl",children:"Step 1: Install and Setup KDL"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Install KDL\nsudo apt install ros-humble-orocos-kdl ros-humble-python-orocos-kdl\n\n# Install Python bindings\npip3 install pykdl-utils\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"step-2-define-robot-chain-in-kdl",children:"Step 2: Define Robot Chain in KDL"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nfrom PyKDL import *\nimport numpy as np\n\ndef create_simple_arm():\n    """Create 3-DOF robot arm chain"""\n    chain = Chain()\n\n    # Joint 1: Revolute around Z, length 0.5m along X\n    joint1 = Joint(Joint.RotZ)\n    frame1 = Frame(Rotation.Identity(), Vector(0.5, 0, 0))\n    segment1 = Segment(joint1, frame1)\n    chain.addSegment(segment1)\n\n    # Joint 2: Revolute around Z, length 0.3m along X\n    joint2 = Joint(Joint.RotZ)\n    frame2 = Frame(Rotation.Identity(), Vector(0.3, 0, 0))\n    segment2 = Segment(joint2, frame2)\n    chain.addSegment(segment2)\n\n    # Joint 3: Revolute around Z, length 0.2m along X\n    joint3 = Joint(Joint.RotZ)\n    frame3 = Frame(Rotation.Identity(), Vector(0.2, 0, 0))\n    segment3 = Segment(joint3, frame3)\n    chain.addSegment(segment3)\n\n    return chain\n\n# Create robot\nrobot_chain = create_simple_arm()\nprint(f"Robot has {robot_chain.getNrOfJoints()} joints")\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"step-3-solve-ik-with-kdl",children:"Step 3: Solve IK with KDL"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from PyKDL import *\nimport numpy as np\n\ndef solve_ik_kdl(chain, target_pose, initial_guess=None):\n    """\n    Solve IK using KDL Newton-Raphson solver\n\n    Args:\n        chain: KDL Chain object\n        target_pose: Desired end-effector pose (Frame)\n        initial_guess: Initial joint angles (JntArray)\n\n    Returns:\n        (success, joint_angles)\n    """\n    # Create solvers\n    fk_solver = ChainFkSolverPos_recursive(chain)\n    ik_solver = ChainIkSolverPos_NR(\n        chain,\n        fk_solver,\n        ChainIkSolverVel_pinv(chain)  # Velocity IK solver\n    )\n\n    # Initial guess (if not provided, use zeros)\n    n_joints = chain.getNrOfJoints()\n    if initial_guess is None:\n        q_init = JntArray(n_joints)\n        for i in range(n_joints):\n            q_init[i] = 0.0\n    else:\n        q_init = initial_guess\n\n    # Solve IK\n    q_out = JntArray(n_joints)\n    result = ik_solver.CartToJnt(q_init, target_pose, q_out)\n\n    # Check if solution found\n    success = (result >= 0)\n\n    # Extract joint angles\n    joint_angles = [q_out[i] for i in range(n_joints)]\n\n    return success, joint_angles\n\n# Usage example\nrobot_chain = create_simple_arm()\n\n# Define target pose: position (0.8, 0.3, 0.0), no rotation\ntarget_position = Vector(0.8, 0.3, 0.0)\ntarget_rotation = Rotation.Identity()\ntarget_frame = Frame(target_rotation, target_position)\n\n# Solve IK\nsuccess, joint_angles = solve_ik_kdl(robot_chain, target_frame)\n\nif success:\n    print(f"\u2705 IK solution found:")\n    for i, angle in enumerate(joint_angles):\n        print(f"  Joint {i+1}: {np.degrees(angle):.2f}\xb0")\n\n    # Verify with FK\n    fk_solver = ChainFkSolverPos_recursive(robot_chain)\n    q = JntArray(len(joint_angles))\n    for i, angle in enumerate(joint_angles):\n        q[i] = angle\n\n    result_frame = Frame()\n    fk_solver.JntToCart(q, result_frame)\n\n    achieved_pos = result_frame.p\n    print(f"\\nVerification (FK):")\n    print(f"  Target:   ({target_position.x():.3f}, {target_position.y():.3f}, {target_position.z():.3f})")\n    print(f"  Achieved: ({achieved_pos.x():.3f}, {achieved_pos.y():.3f}, {achieved_pos.z():.3f})")\nelse:\n    print("\u274c IK solution not found")\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"part-3-advanced-ik-with-trac-ik",children:"Part 3: Advanced IK with TRAC-IK"}),"\n",(0,r.jsx)(e.p,{children:"TRAC-IK is faster and more reliable than KDL for complex robots."}),"\n",(0,r.jsx)(e.h3,{id:"step-1-install-trac-ik",children:"Step 1: Install TRAC-IK"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"sudo apt install ros-humble-trac-ik ros-humble-trac-ik-python\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"step-2-use-trac-ik-in-python",children:"Step 2: Use TRAC-IK in Python"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom trac_ik_python.trac_ik import IK\n\nclass TracIKSolver(Node):\n    def __init__(self):\n        super().__init__(\'trac_ik_solver\')\n\n        # Initialize TRAC-IK\n        # Args: base_link, tip_link, URDF (optional), timeout, epsilon, solve_type\n        self.ik_solver = IK(\n            "base_link",\n            "end_effector_link",\n            urdf_string=self.get_robot_description(),\n            timeout=0.005,  # 5ms\n            epsilon=1e-5,  # Precision\n            solve_type="Speed"  # or "Distance" for better solutions\n        )\n\n    def get_robot_description(self):\n        """Get URDF from parameter server"""\n        # In real application, fetch from /robot_description parameter\n        # For now, return simple URDF\n        urdf = """<?xml version="1.0"?>\n<robot name="simple_arm">\n  <link name="base_link"/>\n  <link name="link1"/>\n  <link name="link2"/>\n  <link name="end_effector_link"/>\n\n  <joint name="joint1" type="revolute">\n    <parent link="base_link"/>\n    <child link="link1"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit effort="100" lower="-3.14" upper="3.14" velocity="1.0"/>\n  </joint>\n\n  <joint name="joint2" type="revolute">\n    <parent link="link1"/>\n    <child link="link2"/>\n    <origin xyz="0.5 0 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit effort="100" lower="-3.14" upper="3.14" velocity="1.0"/>\n  </joint>\n\n  <joint name="joint3" type="revolute">\n    <parent link="link2"/>\n    <child link="end_effector_link"/>\n    <origin xyz="0.3 0 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit effort="100" lower="-3.14" upper="3.14" velocity="1.0"/>\n  </joint>\n</robot>\n"""\n        return urdf\n\n    def solve_ik(self, x, y, z, roll, pitch, yaw, seed_angles=None):\n        """\n        Solve IK using TRAC-IK\n\n        Returns:\n            Joint angles or None if no solution\n        """\n        solution = self.ik_solver.get_ik(\n            seed_angles or [0.0] * 3,  # Initial guess\n            x, y, z,  # Position\n            roll, pitch, yaw  # Orientation (quaternion or RPY)\n        )\n\n        return solution\n\n# Usage\ndef main():\n    rclpy.init()\n    solver = TracIKSolver()\n\n    # Solve IK for target position\n    solution = solver.solve_ik(\n        x=0.7, y=0.2, z=0.1,\n        roll=0.0, pitch=0.0, yaw=0.0\n    )\n\n    if solution:\n        print(f"\u2705 TRAC-IK solution: {[f\'{np.degrees(a):.2f}\xb0\' for a in solution]}")\n    else:\n        print("\u274c No IK solution found")\n\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"part-4-moveit-integration",children:"Part 4: MoveIt Integration"}),"\n",(0,r.jsx)(e.h3,{id:"step-1-create-moveit-config",children:"Step 1: Create MoveIt Config"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Generate MoveIt config for your robot\nros2 launch moveit_setup_assistant setup_assistant.launch.py\n\n# Follow GUI to:\n# 1. Load URDF\n# 2. Define planning groups (arm, gripper)\n# 3. Add end effectors\n# 4. Generate config package\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h3,{id:"step-2-use-moveit-for-ik-in-python",children:"Step 2: Use MoveIt for IK in Python"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom moveit_msgs.srv import GetPositionIK\nfrom moveit_msgs.msg import PositionIKRequest\nfrom geometry_msgs.msg import PoseStamped\n\nclass MoveItIKClient(Node):\n    def __init__(self):\n        super().__init__(\'moveit_ik_client\')\n\n        # Create IK service client\n        self.ik_client = self.create_client(\n            GetPositionIK,\n            \'/compute_ik\'\n        )\n\n        while not self.ik_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Waiting for IK service...\')\n\n    def compute_ik(self, target_pose: PoseStamped, group_name: str = "arm"):\n        """Compute IK using MoveIt"""\n\n        # Create request\n        request = GetPositionIK.Request()\n        request.ik_request.group_name = group_name\n        request.ik_request.pose_stamped = target_pose\n        request.ik_request.timeout.sec = 5\n\n        # Call service\n        future = self.ik_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        response = future.result()\n\n        if response.error_code.val == response.error_code.SUCCESS:\n            joint_state = response.solution.joint_state\n            return joint_state.position\n        else:\n            self.get_logger().error(f\'IK failed with error code: {response.error_code.val}\')\n            return None\n\n# Usage\ndef main():\n    rclpy.init()\n    ik_client = MoveItIKClient()\n\n    # Create target pose\n    target = PoseStamped()\n    target.header.frame_id = "base_link"\n    target.pose.position.x = 0.5\n    target.pose.position.y = 0.3\n    target.pose.position.z = 0.4\n    target.pose.orientation.w = 1.0  # No rotation\n\n    # Compute IK\n    joint_positions = ik_client.compute_ik(target, group_name="arm")\n\n    if joint_positions:\n        print(f"\u2705 Joint positions: {joint_positions}")\n    else:\n        print("\u274c IK failed")\n\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"In this lesson, you learned:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u2705 Forward kinematics with DH parameters"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Inverse kinematics with KDL and TRAC-IK"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 MoveIt integration for motion planning"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Handling singularities and joint limits"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key Takeaways"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"FK"}),": Easy (just matrix multiplication)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"IK"}),": Hard (multiple solutions, singularities)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"TRAC-IK"}),": Faster and more reliable than KDL"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"MoveIt"}),": Production-ready solution with collision avoidance"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"next-lesson",children:"Next Lesson"}),"\n",(0,r.jsxs)(e.p,{children:["Continue to ",(0,r.jsx)(e.a,{href:"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/bipedal-locomotion",children:"Bipedal Locomotion \u2192"})]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function o(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);