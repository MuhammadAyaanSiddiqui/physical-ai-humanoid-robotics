"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[5994],{3420:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>r,toc:()=>s});const r=JSON.parse('{"id":"module-4-vla/ch13-humanoid-control/balance-control","title":"Balance Control and Stabilization","description":"Learning Objectives","source":"@site/docs/module-4-vla/ch13-humanoid-control/balance-control.md","sourceDirName":"module-4-vla/ch13-humanoid-control","slug":"/module-4-vla/ch13-humanoid-control/balance-control","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/balance-control","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-vla/ch13-humanoid-control/balance-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Bipedal Locomotion and Walking Gaits","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/bipedal-locomotion"},"next":{"title":"Humanoid Manipulation and Grasping","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/manipulation"}}');var t=o(4848),a=o(8453);const c={},i="Balance Control and Stabilization",l={},s=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Part 1: COM Tracking",id:"part-1-com-tracking",level:2},{value:"Part 2: Disturbance Rejection",id:"part-2-disturbance-rejection",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"balance-control-and-stabilization",children:"Balance Control and Stabilization"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Implement COM (Center of Mass) tracking"}),"\n",(0,t.jsx)(n.li,{children:"Use PID controllers for balance stabilization"}),"\n",(0,t.jsx)(n.li,{children:"Handle external disturbances (pushes, uneven terrain)"}),"\n",(0,t.jsx)(n.li,{children:"Integrate balance control with walking gaits"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Estimated Time"}),": 3 hours"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"part-1-com-tracking",children:"Part 1: COM Tracking"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass COMController:\n    def __init__(self, kp=50.0, kd=10.0):\n        self.kp = kp  # Proportional gain\n        self.kd = kd  # Derivative gain\n        self.com_error = np.zeros(3)\n        self.com_error_dot = np.zeros(3)\n\n    def compute_force(self, com_desired, com_actual, com_velocity):\n        """\n        Compute corrective force to track desired COM\n\n        F = Kp * (com_desired - com_actual) + Kd * (0 - com_velocity)\n        """\n        self.com_error = com_desired - com_actual\n        self.com_error_dot = -com_velocity\n\n        force = self.kp * self.com_error + self.kd * self.com_error_dot\n\n        return force\n\n# Example\ncontroller = COMController(kp=50.0, kd=10.0)\n\ncom_desired = np.array([0.0, 0.0, 0.9])\ncom_actual = np.array([0.02, -0.01, 0.88])\ncom_vel = np.array([0.1, 0.05, -0.02])\n\nforce = controller.compute_force(com_desired, com_actual, com_vel)\nprint(f"Corrective force: {force}")\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"part-2-disturbance-rejection",children:"Part 2: Disturbance Rejection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class BalanceRecovery:\n    def __init__(self):\n        self.max_recovery_step = 0.3  # meters\n\n    def compute_recovery_step(self, com_position, com_velocity, zmp_position):\n        """\n        Compute recovery step when pushed\n\n        Uses Capture Point method\n        """\n        omega = np.sqrt(9.81 / com_position[2])  # Natural frequency\n\n        # Capture point = where COM will be if we don\'t act\n        capture_point = com_position[:2] + com_velocity[:2] / omega\n\n        # Recovery step should land at capture point\n        recovery_step = capture_point - zmp_position\n\n        # Limit step size\n        step_magnitude = np.linalg.norm(recovery_step)\n        if step_magnitude > self.max_recovery_step:\n            recovery_step = recovery_step / step_magnitude * self.max_recovery_step\n\n        return recovery_step\n\nrecovery = BalanceRecovery()\n\n# Robot pushed forward\ncom_pos = np.array([0.0, 0.0, 0.9])\ncom_vel = np.array([0.8, 0.0, 0.0])  # Fast forward velocity!\nzmp = np.array([0.0, 0.0])\n\nstep = recovery.compute_recovery_step(com_pos, com_vel, zmp)\nprint(f"Recovery step: {step} meters")\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 COM tracking with PID control"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Disturbance rejection strategies"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Capture Point method for recovery"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Continue to ",(0,t.jsx)(n.a,{href:"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/manipulation",children:"Manipulation \u2192"})]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>i});var r=o(6540);const t={},a=r.createContext(t);function c(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);