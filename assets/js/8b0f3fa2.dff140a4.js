"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[4233],{314:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"module-2-simulation/ch6-unity/tcp-ros2-comm","title":"Unity to ROS 2 Communication with the TCP Connector","description":"With your robot imported and your connection configured, it\'s time to make Unity \\"talk\\" to ROS 2. This communication is handled by the ROS TCP Connector package, which allows C# scripts in Unity to publish and subscribe to ROS 2 topics.","source":"@site/docs/module-2-simulation/ch6-unity/tcp-ros2-comm.md","sourceDirName":"module-2-simulation/ch6-unity","slug":"/module-2-simulation/ch6-unity/tcp-ros2-comm","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch6-unity/tcp-ros2-comm","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-simulation/ch6-unity/tcp-ros2-comm.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Importing and Configuring Robot Models in Unity","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch6-unity/importing-models"},"next":{"title":"Creating Interactive Scenarios in Unity","permalink":"/physical-ai-humanoid-robotics/docs/module-2-simulation/ch6-unity/interactive-scenarios"}}');var s=i(4848),o=i(8453);const r={},c="Unity to ROS 2 Communication with the TCP Connector",a={},l=[{value:"The Communication Architecture",id:"the-communication-architecture",level:2},{value:"Publishing from Unity to ROS 2",id:"publishing-from-unity-to-ros-2",level:2},{value:"Subscribing to ROS 2 Topics in Unity",id:"subscribing-to-ros-2-topics-in-unity",level:2},{value:"Important Considerations",id:"important-considerations",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"unity-to-ros-2-communication-with-the-tcp-connector",children:"Unity to ROS 2 Communication with the TCP Connector"})}),"\n",(0,s.jsxs)(n.p,{children:['With your robot imported and your connection configured, it\'s time to make Unity "talk" to ROS 2. This communication is handled by the ',(0,s.jsx)(n.strong,{children:"ROS TCP Connector"})," package, which allows C# scripts in Unity to publish and subscribe to ROS 2 topics."]}),"\n",(0,s.jsx)(n.h2,{id:"the-communication-architecture",children:"The Communication Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ROS TCP Connector"})," in Unity and the ",(0,s.jsx)(n.code,{children:"ros_tcp_endpoint"})," on the ROS 2 machine work together as a client-server pair."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unity (Client)"}),": Your C# scripts use the ",(0,s.jsx)(n.code,{children:"ROSConnection"})," object to register topics they want to publish or subscribe to. When you enter Play mode, Unity establishes a single, persistent TCP connection to the ROS 2 endpoint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROS 2 (Server)"}),": The ",(0,s.jsx)(n.code,{children:"ros_tcp_endpoint"})," node listens for this incoming TCP connection. Once connected, it acts as a proxy:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It subscribes to ROS 2 topics on behalf of Unity. When it receives a message, it forwards it over the TCP socket to Unity."}),"\n",(0,s.jsx)(n.li,{children:"It creates ROS 2 publishers on behalf of Unity. When it receives data from Unity over the TCP socket, it publishes it as a ROS 2 message."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:'graph TD\n    subgraph "Unity Scene"\n        A[C# Script<br>(Publisher)]\n        B[C# Script<br>(Subscriber)]\n        C[ROSConnection Singleton]\n        A --\x3e C\n        B --\x3e C\n    end\n\n    subgraph "ROS 2 Graph"\n        F[ROS 2 Node]\n        G[ROS 2 Topic]\n        H[ROS 2 Node]\n        I[ROS 2 Topic]\n        F --\x3e G\n        I --\x3e H\n    end\n    \n    C -- TCP/IP Socket --\x3e D[ros_tcp_endpoint]\n\n    subgraph "TCP Proxy"\n        D\n    end\n\n    D -- "Publishes to ROS 2 Topic" --\x3e G\n    D -- "Subscribes to ROS 2 Topic" --\x3e I\n\n    style C fill:#ccf,stroke:#333,stroke-width:2px\n    style D fill:#cfc,stroke:#333,stroke-width:2px\n'})}),"\n",(0,s.jsx)(n.p,{children:"This architecture is efficient because it uses a single TCP connection to multiplex all topic data, avoiding the overhead of creating multiple sockets."}),"\n",(0,s.jsx)(n.h2,{id:"publishing-from-unity-to-ros-2",children:"Publishing from Unity to ROS 2"}),"\n",(0,s.jsx)(n.p,{children:'Let\'s create a C# script that publishes a simple "Hello World" message from Unity to a ROS 2 topic.'}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create a C# Script"}),": In your ",(0,s.jsx)(n.code,{children:"Assets"})," folder, create a script named ",(0,s.jsx)(n.code,{children:"RosPublisher.cs"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Attach it to an object"}),": Create an empty ",(0,s.jsx)(n.code,{children:"GameObject"}),' in your scene (right-click in Hierarchy > Create Empty) and name it "RosManager". Drag your ',(0,s.jsx)(n.code,{children:"RosPublisher.cs"})," script onto it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edit the script"}),":"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Std; // Import the message type\n\npublic class RosPublisher : MonoBehaviour\n{\n    // ROS Connection\n    private ROSConnection ros;\n    \n    // Topic name\n    private string topicName = "unity_chatter";\n\n    // Message to publish\n    private StringMsg message;\n\n    // Publish frequency (in seconds)\n    private float publishMessageFrequency = 1.0f;\n    private float timeElapsed;\n\n    void Start()\n    {\n        // Get the ROS connection instance\n        ros = ROSConnection.GetOrCreateInstance();\n        \n        // Register the publisher\n        ros.RegisterPublisher<StringMsg>(topicName);\n\n        // Initialize the message\n        message = new StringMsg("Hello from Unity!");\n    }\n\n    void Update()\n    {\n        timeElapsed += Time.deltaTime;\n\n        if (timeElapsed > publishMessageFrequency)\n        {\n            // Update the message data (e.g., with a timestamp)\n            message.data = $"Hello from Unity! Time: {Time.time}";\n\n            // Publish the message\n            ros.Publish(topicName, message);\n            \n            Debug.Log($"Published: {message.data}");\n\n            // Reset the timer\n            timeElapsed = 0;\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this script does:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"Start()"}),", it gets the ",(0,s.jsx)(n.code,{children:"ROSConnection"})," singleton and calls ",(0,s.jsx)(n.code,{children:"RegisterPublisher<StringMsg>(topicName)"}),". This tells the ",(0,s.jsx)(n.code,{children:"ros_tcp_endpoint"})," to create a publisher for the ",(0,s.jsx)(n.code,{children:"unity_chatter"})," topic."]}),"\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"Update()"}),", which is called every frame, it uses a simple timer to publish a message once per second."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ros.Publish(topicName, message)"})," sends the message data over the TCP socket to the endpoint, which then publishes it to the ROS 2 graph."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"To test it:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Run the ",(0,s.jsx)(n.code,{children:"ros_tcp_endpoint"})," on your ROS 2 machine."]}),"\n",(0,s.jsx)(n.li,{children:"Press Play in Unity."}),"\n",(0,s.jsxs)(n.li,{children:["In your ROS 2 terminal, listen to the topic:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ros2 topic echo /unity_chatter\n"})}),"\n",'You should see the "Hello from Unity!" messages appearing once per second.']}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"subscribing-to-ros-2-topics-in-unity",children:"Subscribing to ROS 2 Topics in Unity"}),"\n",(0,s.jsxs)(n.p,{children:["Now let's do the reverse: subscribe to a ROS 2 topic to control an object in Unity. We'll make a script that listens for ",(0,s.jsx)(n.code,{children:"geometry_msgs/Twist"})," messages to move a cube."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create a Cube"}),": In Unity, right-click in the Hierarchy > 3D Object > Cube."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create a C# Script"}),": Create a script named ",(0,s.jsx)(n.code,{children:"RosSubscriber.cs"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Attach and Edit"}),": Attach the script to the Cube object you just created. Edit the script:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using UnityEngine;\nusing Unity.Robotics.ROSTCPConnector;\nusing RosMessageTypes.Geometry; // Import Twist message\n\npublic class RosSubscriber : MonoBehaviour\n{\n    // ROS Connection\n    private ROSConnection ros;\n    \n    // Topic name\n    private string topicName = "/cmd_vel";\n\n    // Movement speed\n    public float linearSpeed = 2.0f;\n    public float angularSpeed = 180.0f; // degrees per second\n\n    private Vector3 linearVelocity;\n    private float angularVelocity;\n\n    void Start()\n    {\n        // Get the ROS connection instance\n        ros = ROSConnection.GetOrCreateInstance();\n        \n        // Subscribe to the topic\n        ros.Subscribe<TwistMsg>(topicName, ReceiveTwistCommand);\n    }\n\n    void Update()\n    {\n        // Apply the received velocities\n        transform.Translate(linearVelocity * Time.deltaTime, Space.World);\n        transform.Rotate(0, angularVelocity * Time.deltaTime, 0);\n    }\n\n    // Callback function for when a message is received\n    void ReceiveTwistCommand(TwistMsg message)\n    {\n        // Convert ROS coordinate system (right-hand rule, Z-up)\n        // to Unity coordinate system (left-hand rule, Y-up)\n        \n        // ROS linear.x (forward) -> Unity transform.forward (which is local Z)\n        // ROS linear.y (left) -> Unity -transform.right (which is local -X)\n        // ROS angular.z (yaw) -> Unity rotation around Y axis\n        \n        linearVelocity = new Vector3((float)message.linear.y, 0, (float)message.linear.x) * linearSpeed;\n        angularVelocity = -(float)message.angular.z * angularSpeed;\n        \n        Debug.Log($"Received Twist: Linear={linearVelocity}, Angular={angularVelocity}");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this script does:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"Start()"}),", it subscribes to the ",(0,s.jsx)(n.code,{children:"/cmd_vel"})," topic and registers the ",(0,s.jsx)(n.code,{children:"ReceiveTwistCommand"})," function as the callback."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"ReceiveTwistCommand"})," function is executed every time a message arrives. It extracts the linear and angular velocities from the ",(0,s.jsx)(n.code,{children:"TwistMsg"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Coordinate System Conversion is CRITICAL"}),": Note the conversion from ROS to Unity conventions. This is a common source of bugs."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.code,{children:"Update()"}),", the script continuously applies the last received velocities to the cube's ",(0,s.jsx)(n.code,{children:"transform"}),", making it move and rotate smoothly."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"To test it:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Run the ",(0,s.jsx)(n.code,{children:"ros_tcp_endpoint"})," on your ROS 2 machine."]}),"\n",(0,s.jsx)(n.li,{children:"Press Play in Unity."}),"\n",(0,s.jsxs)(n.li,{children:["In your ROS 2 terminal, publish a ",(0,s.jsx)(n.code,{children:"Twist"})," message:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Move forward\nros2 topic pub --once /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 1.0}}"\n\n# Turn left\nros2 topic pub --once /cmd_vel geometry_msgs/msg/Twist "{angular: {z: 0.5}}"\n'})}),"\n","You should see the cube in your Unity scene move and rotate in response to your commands."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Types"}),": The ",(0,s.jsx)(n.code,{children:"ROS TCP Connector"})," automatically generates C# class definitions for standard ROS 2 messages. If you have custom messages in your ROS 2 workspace, you must generate their C# equivalents. You can do this from the Unity Editor menu: ",(0,s.jsx)(n.strong,{children:"Robotics > Generate ROS Messages..."}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": While the TCP connector is efficient, sending large amounts of data (like high-resolution images or point clouds) at a high frequency can still cause network latency. Always consider the data rates your application requires."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": In a real application, you would want to add logic to handle disconnections and reconnections to the ROS endpoint. The ",(0,s.jsx)(n.code,{children:"ROSConnection"})," object provides status events you can subscribe to for this purpose."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'By mastering publishing and subscribing, you have the complete toolkit to create a "digital twin" in Unity that can both be controlled by and provide sensor data to your ROS 2 algorithms.'})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);