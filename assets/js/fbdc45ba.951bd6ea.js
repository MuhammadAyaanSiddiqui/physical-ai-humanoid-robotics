"use strict";(globalThis.webpackChunkphysical_ai_course=globalThis.webpackChunkphysical_ai_course||[]).push([[8294],{2775:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-4-vla/ch13-humanoid-control/bipedal-locomotion","title":"Bipedal Locomotion and Walking Gaits","description":"Learning Objectives","source":"@site/docs/module-4-vla/ch13-humanoid-control/bipedal-locomotion.md","sourceDirName":"module-4-vla/ch13-humanoid-control","slug":"/module-4-vla/ch13-humanoid-control/bipedal-locomotion","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/bipedal-locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-vla/ch13-humanoid-control/bipedal-locomotion.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Forward and Inverse Kinematics for Humanoid Robots","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/forward-inverse-kinematics"},"next":{"title":"Balance Control and Stabilization","permalink":"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/balance-control"}}');var i=o(4848),a=o(8453);const s={},l="Bipedal Locomotion and Walking Gaits",r={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Part 1: Gait Fundamentals",id:"part-1-gait-fundamentals",level:2},{value:"Walking Cycle Phases",id:"walking-cycle-phases",level:3},{value:"Part 2: ZMP Control",id:"part-2-zmp-control",level:2},{value:"Part 3: Footstep Planning",id:"part-3-footstep-planning",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"bipedal-locomotion-and-walking-gaits",children:"Bipedal Locomotion and Walking Gaits"})}),"\n",(0,i.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Understand bipedal walking principles (ZMP, COM, gait cycles)"}),"\n",(0,i.jsx)(e.li,{children:"Implement walking gaits for humanoid robots"}),"\n",(0,i.jsx)(e.li,{children:"Use Zero Moment Point (ZMP) for balance control"}),"\n",(0,i.jsx)(e.li,{children:"Generate footstep plans and trajectories"}),"\n",(0,i.jsx)(e.li,{children:"Simulate walking in Isaac Sim"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Prerequisites"}),": Kinematics, Python, ROS 2, Isaac Sim"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Estimated Time"}),": 4 hours"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(e.p,{children:"Bipedal walking involves:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Gait cycle"}),": Swing phase (foot in air) + Stance phase (foot on ground)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ZMP (Zero Moment Point)"}),": Point where net moment = 0 (must stay in support polygon)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"COM (Center of Mass)"}),": Must be controlled to maintain balance"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"part-1-gait-fundamentals",children:"Part 1: Gait Fundamentals"}),"\n",(0,i.jsx)(e.h3,{id:"walking-cycle-phases",children:"Walking Cycle Phases"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class GaitPhase:\n    DOUBLE_SUPPORT = "double_support"  # Both feet on ground\n    LEFT_SWING = "left_swing"          # Right foot support\n    RIGHT_SWING = "right_swing"        # Left foot support\n\n    def __init__(self):\n        self.current_phase = self.DOUBLE_SUPPORT\n        self.phase_duration = 0.1  # seconds\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"part-2-zmp-control",children:"Part 2: ZMP Control"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\ndef compute_zmp(com_position, com_acceleration, gravity=9.81):\n    """\n    Calculate ZMP from COM state\n\n    ZMP_x = COM_x - (COM_z / g) * COM_acc_x\n    """\n    zmp_x = com_position[0] - (com_position[2] / gravity) * com_acceleration[0]\n    zmp_y = com_position[1] - (com_position[2] / gravity) * com_acceleration[1]\n\n    return np.array([zmp_x, zmp_y])\n\n# Example\ncom_pos = np.array([0.0, 0.0, 0.9])  # meters\ncom_acc = np.array([0.5, 0.0, 0.0])   # m/s^2\n\nzmp = compute_zmp(com_pos, com_acc)\nprint(f"ZMP: x={zmp[0]:.3f}, y={zmp[1]:.3f}")\n'})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"part-3-footstep-planning",children:"Part 3: Footstep Planning"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"class FootstepPlanner:\n    def __init__(self, step_length=0.2, step_width=0.15):\n        self.step_length = step_length  # Forward step distance\n        self.step_width = step_width    # Lateral foot spacing\n\n    def generate_forward_steps(self, num_steps):\n        \"\"\"Generate footsteps for forward walking\"\"\"\n        footsteps = []\n\n        for i in range(num_steps):\n            if i % 2 == 0:  # Left foot\n                x = (i // 2) * self.step_length\n                y = self.step_width / 2\n                foot = \"left\"\n            else:  # Right foot\n                x = (i // 2 + 1) * self.step_length\n                y = -self.step_width / 2\n                foot = \"right\"\n\n            footsteps.append({\n                'foot': foot,\n                'position': np.array([x, y, 0.0]),\n                'orientation': 0.0  # yaw angle\n            })\n\n        return footsteps\n\n# Generate 10 steps\nplanner = FootstepPlanner(step_length=0.25, step_width=0.20)\nsteps = planner.generate_forward_steps(10)\n\nfor i, step in enumerate(steps):\n    print(f\"Step {i}: {step['foot']} at ({step['position'][0]:.2f}, {step['position'][1]:.2f})\")\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u2705 Gait cycles and phases"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 ZMP computation for balance"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Footstep planning algorithms"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["Continue to ",(0,i.jsx)(e.a,{href:"/physical-ai-humanoid-robotics/docs/module-4-vla/ch13-humanoid-control/balance-control",children:"Balance Control \u2192"})]})]})}function p(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>l});var t=o(6540);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);