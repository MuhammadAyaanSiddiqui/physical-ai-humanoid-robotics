#!/usr/bin/env python3
"""
ROS 2 Action Server for LLM-Generated Actions

Executes actions generated by LLM planner.
"""

import rclpy
from rclpy.node import Node
from rclpy.action import ActionServer
from my_robot_interfaces.action import ExecuteAction
import time

class RobotActionServer(Node):
    def __init__(self):
        super().__init__('robot_action_server')

        self._action_server = ActionServer(
            self,
            ExecuteAction,
            'execute_action',
            self.execute_callback
        )

        self.get_logger().info('Robot Action Server ready')

    def execute_callback(self, goal_handle):
        """Execute action goal"""
        self.get_logger().info(f'Executing: {goal_handle.request.action_type}')

        action_type = goal_handle.request.action_type

        # Simulate action execution
        if action_type == 'navigate':
            return self.navigate(goal_handle)
        elif action_type == 'pick':
            return self.pick(goal_handle)
        elif action_type == 'place':
            return self.place(goal_handle)
        elif action_type == 'scan':
            return self.scan(goal_handle)

        goal_handle.abort()
        return ExecuteAction.Result(success=False, message="Unknown action")

    def navigate(self, goal_handle):
        """Navigate to location"""
        location = goal_handle.request.location

        # Simulate navigation with feedback
        for i in range(10):
            feedback = ExecuteAction.Feedback()
            feedback.progress = (i + 1) * 10
            feedback.current_status = f"Navigating to {location}..."
            goal_handle.publish_feedback(feedback)
            time.sleep(0.5)

        goal_handle.succeed()
        return ExecuteAction.Result(
            success=True,
            message=f"Arrived at {location}"
        )

    def pick(self, goal_handle):
        """Pick object"""
        obj = goal_handle.request.object_name

        # Simulate picking
        for i in range(5):
            feedback = ExecuteAction.Feedback()
            feedback.progress = (i + 1) * 20
            feedback.current_status = f"Picking {obj}..."
            goal_handle.publish_feedback(feedback)
            time.sleep(0.3)

        goal_handle.succeed()
        return ExecuteAction.Result(
            success=True,
            message=f"Picked {obj}"
        )

    def place(self, goal_handle):
        """Place object"""
        obj = goal_handle.request.object_name
        location = goal_handle.request.location

        for i in range(5):
            feedback = ExecuteAction.Feedback()
            feedback.progress = (i + 1) * 20
            feedback.current_status = f"Placing {obj} on {location}..."
            goal_handle.publish_feedback(feedback)
            time.sleep(0.3)

        goal_handle.succeed()
        return ExecuteAction.Result(
            success=True,
            message=f"Placed {obj} on {location}"
        )

    def scan(self, goal_handle):
        """Scan environment"""
        for i in range(3):
            feedback = ExecuteAction.Feedback()
            feedback.progress = (i + 1) * 33
            feedback.current_status = "Scanning..."
            goal_handle.publish_feedback(feedback)
            time.sleep(0.5)

        goal_handle.succeed()
        return ExecuteAction.Result(
            success=True,
            message="Scan complete"
        )

def main(args=None):
    rclpy.init(args=args)
    server = RobotActionServer()

    try:
        rclpy.spin(server)
    except KeyboardInterrupt:
        pass
    finally:
        server.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
